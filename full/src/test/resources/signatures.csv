name,signature
algo.allShortestPaths.stream,"algo.allShortestPaths.stream(propertyName :: STRING?, config = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, distance :: FLOAT?)"
algo.articleRank,"algo.articleRank(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.articleRank.stream,"algo.articleRank.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.asPath,"algo.asPath(nodeIds = [] :: LIST? OF INTEGER?, weights = [] :: LIST? OF FLOAT?, config = {} :: MAP?) :: (path :: PATH?)"
algo.balancedTriads,"algo.balancedTriads(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, balancedTriadCount :: INTEGER?, unbalancedTriadCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, balancedProperty :: STRING?, unbalancedProperty :: STRING?)"
algo.balancedTriads.stream,"algo.balancedTriads.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, balanced :: INTEGER?, unbalanced :: INTEGER?)"
algo.beta.labelPropagation,"algo.beta.labelPropagation(label =  :: STRING?, relationship =  :: STRING?, config = null :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, didConverge :: BOOLEAN?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, weightProperty :: STRING?, write :: BOOLEAN?, seedProperty :: STRING?, writeProperty :: STRING?)"
algo.beta.labelPropagation.stream,"algo.beta.labelPropagation.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, community :: INTEGER?)"
algo.betweenness,"algo.betweenness(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?, minCentrality :: FLOAT?, maxCentrality :: FLOAT?, sumCentrality :: FLOAT?)"
algo.betweenness.sampled,"algo.betweenness.sampled(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?, minCentrality :: FLOAT?, maxCentrality :: FLOAT?, sumCentrality :: FLOAT?)"
algo.betweenness.sampled.stream,"algo.betweenness.sampled.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.betweenness.stream,"algo.betweenness.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.bfs.stream,"algo.bfs.stream(label :: STRING?, relationshipType :: STRING?, direction :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.closeness,"algo.closeness(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.dangalchev,"algo.closeness.dangalchev(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.dangalchev.stream,"algo.closeness.dangalchev.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.closeness.harmonic,"algo.closeness.harmonic(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.harmonic.stream,"algo.closeness.harmonic.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.closeness.stream,"algo.closeness.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.degree,"algo.degree(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.degree.stream,"algo.degree.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.dfs.stream,"algo.dfs.stream(label :: STRING?, relationshipType :: STRING?, direction :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.eigenvector,"algo.eigenvector(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.eigenvector.stream,"algo.eigenvector.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.graph.info,"algo.graph.info(name :: STRING?, degreeDistribution = null :: ANY?) :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?)"
algo.graph.list,"algo.graph.list() :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, removed :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, direction :: STRING?)"
algo.graph.load,"algo.graph.load(name =  :: STRING?, label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (name :: STRING?, graph :: STRING?, direction :: STRING?, undirected :: BOOLEAN?, sorted :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, loadMillis :: INTEGER?, alreadyLoaded :: BOOLEAN?, nodeWeight :: STRING?, relationshipWeight :: STRING?, nodeProperty :: STRING?, loadNodes :: STRING?, loadRelationships :: STRING?)"
algo.graph.load.memrec,"algo.graph.load.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.graph.remove,"algo.graph.remove(name :: STRING?) :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, removed :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, direction :: STRING?)"
algo.infoMap,"algo.infoMap(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, iterations :: INTEGER?, communityCount :: INTEGER?)"
algo.infoMap.stream,"algo.infoMap.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, community :: INTEGER?)"
algo.kShortestPaths,"algo.kShortestPaths(startNode :: NODE?, endNode :: NODE?, k :: INTEGER?, propertyName :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, evalMillis :: INTEGER?, writeMillis :: INTEGER?, resultCount :: INTEGER?)"
algo.kShortestPaths.stream,"algo.kShortestPaths.stream(startNode :: NODE?, endNode :: NODE?, k :: INTEGER?, propertyName :: STRING?, config = {} :: MAP?) :: (index :: INTEGER?, sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
algo.labelPropagation,"algo.labelPropagation(label =  :: STRING?, relationship =  :: STRING?, config = null :: ANY?, deprecatedConfig = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, didConverge :: BOOLEAN?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, weightProperty :: STRING?, write :: BOOLEAN?, seedProperty :: STRING?, writeProperty :: STRING?)"
algo.labelPropagation.memRec,"algo.labelPropagation.memRec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.labelPropagation.stream,"algo.labelPropagation.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, label :: INTEGER?)"
algo.list,"algo.list(name =  :: STRING?) :: (name :: STRING?, description :: STRING?, signature :: STRING?, type :: STRING?)"
algo.louvain,"algo.louvain(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, modularities :: LIST? OF FLOAT?, modularity :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, includeIntermediateCommunities :: BOOLEAN?, intermediateCommunitiesWriteProperty :: STRING?, randomNeighbor :: BOOLEAN?)"
algo.louvain.memrec,"algo.louvain.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.louvain.stream,"algo.louvain.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, communities :: LIST? OF INTEGER?, community :: INTEGER?)"
algo.memrec,"algo.memrec(label =  :: STRING?, relationship =  :: STRING?, algo =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.mst,"algo.mst(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.pageRank,"algo.pageRank(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.pageRank.memrec,"algo.pageRank.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.pageRank.stream,"algo.pageRank.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.randomWalk.stream,"algo.randomWalk.stream(start = null :: ANY?, steps = 10 :: INTEGER?, walks = 1 :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.scc,"algo.scc(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.forwardBackward.stream,"algo.scc.forwardBackward.stream(startNodeId = 0 :: INTEGER?, label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?)"
algo.scc.iterative,"algo.scc.iterative(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.iterative.stream,"algo.scc.iterative.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.multistep,"algo.scc.multistep(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.multistep.stream,"algo.scc.multistep.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.recursive.tarjan,"algo.scc.recursive.tarjan(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.recursive.tunedTarjan,"algo.scc.recursive.tunedTarjan(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.recursive.tunedTarjan.stream,"algo.scc.recursive.tunedTarjan.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.stream,"algo.scc.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.shortestPath,"algo.shortestPath(startNode :: NODE?, endNode :: NODE?, propertyName =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, evalMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, totalCost :: FLOAT?)"
algo.shortestPath.astar.stream,"algo.shortestPath.astar.stream(startNode :: NODE?, endNode :: NODE?, propertyName :: STRING?, propertyKeyLat = latitude :: STRING?, propertyKeyLon = longitude :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, cost :: FLOAT?)"
algo.shortestPath.deltaStepping,"algo.shortestPath.deltaStepping(startNode :: NODE?, propertyName :: STRING?, delta :: FLOAT?, config = {} :: MAP?) :: (loadDuration :: INTEGER?, evalDuration :: INTEGER?, writeDuration :: INTEGER?, nodeCount :: INTEGER?)"
algo.shortestPath.deltaStepping.stream,"algo.shortestPath.deltaStepping.stream(startNode :: NODE?, propertyName :: STRING?, delta :: FLOAT?, config = {} :: MAP?) :: (nodeId :: INTEGER?, distance :: FLOAT?)"
algo.shortestPath.stream,"algo.shortestPath.stream(startNode :: NODE?, endNode :: NODE?, propertyName =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, cost :: FLOAT?)"
algo.shortestPaths,"algo.shortestPaths(startNode :: NODE?, propertyName :: STRING?, config = {} :: MAP?) :: (loadDuration :: INTEGER?, evalDuration :: INTEGER?, writeDuration :: INTEGER?, nodeCount :: INTEGER?, targetProperty :: STRING?)"
algo.shortestPaths.stream,"algo.shortestPaths.stream(startNode :: NODE?, propertyName :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, distance :: FLOAT?)"
algo.similarity.cosine,"algo.similarity.cosine(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.cosine.stream,"algo.similarity.cosine.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.euclidean,"algo.similarity.euclidean(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.euclidean.stream,"algo.similarity.euclidean.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.jaccard,"algo.similarity.jaccard(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.jaccard.stream,"algo.similarity.jaccard.stream(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.overlap,"algo.similarity.overlap(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.overlap.stream,"algo.similarity.overlap.stream(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.pearson,"algo.similarity.pearson(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.pearson.stream,"algo.similarity.pearson.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.spanningTree,"algo.spanningTree(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.kmax,"algo.spanningTree.kmax(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, k :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.kmin,"algo.spanningTree.kmin(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, k :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.maximum,"algo.spanningTree.maximum(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.minimum,"algo.spanningTree.minimum(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.triangle.stream,"algo.triangle.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeA :: INTEGER?, nodeB :: INTEGER?, nodeC :: INTEGER?)"
algo.triangleCount,"algo.triangleCount(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, triangleCount :: INTEGER?, averageClusteringCoefficient :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, clusteringCoefficientProperty :: STRING?)"
algo.triangleCount.forkJoin,"algo.triangleCount.forkJoin(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, triangleCount :: INTEGER?, averageClusteringCoefficient :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, clusteringCoefficientProperty :: STRING?)"
algo.triangleCount.forkJoin.stream,"algo.triangleCount.forkJoin.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, triangles :: INTEGER?, coefficient :: FLOAT?)"
algo.triangleCount.stream,"algo.triangleCount.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, triangles :: INTEGER?, coefficient :: FLOAT?)"
algo.unionFind,"algo.unionFind(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoin,"algo.unionFind.forkJoin(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoin.stream,"algo.unionFind.forkJoin.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.forkJoinMerge,"algo.unionFind.forkJoinMerge(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoinMerge.stream,"algo.unionFind.forkJoinMerge.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.memrec,"algo.unionFind.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.unionFind.mscoloring,"algo.unionFind.mscoloring(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.mscoloring.stream,"algo.unionFind.mscoloring.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, color :: INTEGER?)"
algo.unionFind.queue,"algo.unionFind.queue(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.queue.stream,"algo.unionFind.queue.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.stream,"algo.unionFind.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
apoc.algo.aStar,"apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)"
apoc.algo.aStarConfig,"apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)"
apoc.algo.allSimplePaths,"apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)"
apoc.algo.cliques,apoc.algo.cliques(minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)
apoc.algo.cliquesWithNode,"apoc.algo.cliquesWithNode(startNode :: NODE?, minSize :: NUMBER?) :: (clique :: LIST? OF NODE?)"
apoc.algo.community,"apoc.algo.community(times :: INTEGER?, labels :: LIST? OF STRING?, partitionKey :: STRING?, type :: STRING?, direction :: STRING?, weightKey :: STRING?, batchSize :: INTEGER?) :: VOID"
apoc.algo.cover,apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)
apoc.algo.dijkstra,"apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight = NaN :: FLOAT?, numberOfWantedPaths = 1 :: INTEGER?) :: (path :: PATH?, weight :: FLOAT?)"
apoc.algo.dijkstraWithDefaultWeight,"apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)"
apoc.algo.pageRank,"apoc.algo.pageRank(nodes :: LIST? OF NODE?) :: (node :: NODE?, score :: FLOAT?)"
apoc.algo.pageRankStats,"apoc.algo.pageRankStats(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)"
apoc.algo.pageRankWithConfig,"apoc.algo.pageRankWithConfig(nodes :: LIST? OF NODE?, config :: MAP?) :: (node :: NODE?, score :: FLOAT?)"
apoc.algo.pageRankWithCypher,"apoc.algo.pageRankWithCypher(config :: MAP?) :: (nodes :: INTEGER?, relationships :: INTEGER?, iterations :: INTEGER?, readNodeMillis :: INTEGER?, readRelationshipMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, property :: STRING?)"
apoc.algo.wcc,"apoc.algo.wcc() :: (nodeIds :: LIST? OF INTEGER?, stats :: MAP?)"
apoc.atomic.add,"apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.concat,"apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.insert,"apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.remove,"apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.subtract,"apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.update,"apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.bolt.execute,"apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.bolt.load,"apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.case,"apoc.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)"
apoc.cluster.graph,"apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.coll.elements,"apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)"
apoc.coll.partition,"apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)"
apoc.coll.split,"apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)"
apoc.coll.zipToRows,"apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)"
apoc.config.list,"apoc.config.list() :: (key :: STRING?, value :: ANY?)"
apoc.config.map,apoc.config.map() :: (value :: MAP?)
apoc.convert.setJsonProperty,"apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID"
apoc.convert.toTree,"apoc.convert.toTree(paths :: LIST? OF PATH?, lowerCaseRels = true :: BOOLEAN?, config = {} :: MAP?) :: (value :: MAP?)"
apoc.couchbase.append,"apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.exists,"apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)"
apoc.couchbase.get,"apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.insert,"apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.namedParamsQuery,"apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.posParamsQuery,"apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.prepend,"apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.query,"apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.remove,"apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.replace,"apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.upsert,"apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.create.addLabels,"apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)"
apoc.create.node,"apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)"
apoc.create.nodes,"apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)"
apoc.create.relationship,"apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)"
apoc.create.removeLabels,"apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)"
apoc.create.removeProperties,"apoc.create.removeProperties(nodes :: ANY?, keys :: LIST? OF STRING?) :: (node :: NODE?)"
apoc.create.removeRelProperties,"apoc.create.removeRelProperties(rels :: ANY?, keys :: LIST? OF STRING?) :: (rel :: RELATIONSHIP?)"
apoc.create.setLabels,"apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)"
apoc.create.setProperties,"apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)"
apoc.create.setProperty,"apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)"
apoc.create.setRelProperties,"apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)"
apoc.create.setRelProperty,"apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)"
apoc.create.uuids,"apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)"
apoc.create.vNode,"apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)"
apoc.create.vNodes,"apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)"
apoc.create.vPattern,"apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)"
apoc.create.vPatternFull,"apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)"
apoc.create.vRelationship,"apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)"
apoc.custom.asFunction,"apoc.custom.asFunction(name :: STRING?, statement :: STRING?, outputs =  :: STRING?, inputs = null :: LIST? OF LIST? OF STRING?, forceSingle = false :: BOOLEAN?, description = null :: STRING?) :: VOID"
apoc.custom.asProcedure,"apoc.custom.asProcedure(name :: STRING?, statement :: STRING?, mode = read :: STRING?, outputs = null :: LIST? OF LIST? OF STRING?, inputs = null :: LIST? OF LIST? OF STRING?, description = null :: STRING?) :: VOID"
apoc.custom.list,"apoc.custom.list() :: (type :: STRING?, name :: STRING?, description :: STRING?, mode :: STRING?, statement :: STRING?, inputs :: LIST? OF LIST? OF STRING?, outputs :: ANY?, forceSingle :: BOOLEAN?)"
apoc.cypher.doIt,"apoc.cypher.doIt(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)"
apoc.cypher.mapParallel,"apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)"
apoc.cypher.mapParallel2,"apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout = 10 :: INTEGER?) :: (value :: MAP?)"
apoc.cypher.parallel,"apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)"
apoc.cypher.parallel2,"apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)"
apoc.cypher.run,"apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)"
apoc.cypher.runFile,"apoc.cypher.runFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runFiles,"apoc.cypher.runFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runMany,"apoc.cypher.runMany(cypher :: STRING?, params :: MAP?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runSchemaFile,"apoc.cypher.runSchemaFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runSchemaFiles,"apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runTimeboxed,"apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)"
apoc.date.expire,"apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID"
apoc.date.expireIn,"apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID"
apoc.do.case,"apoc.do.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)"
apoc.do.when,"apoc.do.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)"
apoc.es.get,"apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.getRaw,"apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.post,"apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)"
apoc.es.postRaw,"apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.put,"apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)"
apoc.es.query,"apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.stats,apoc.es.stats(host :: STRING?) :: (value :: MAP?)
apoc.example.movies,"apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.csv.all,"apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.csv.data,"apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.csv.graph,"apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.csv.query,"apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.cypher.all,"apoc.export.cypher.all(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypher.data,"apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypher.graph,"apoc.export.cypher.graph(graph :: MAP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypher.query,"apoc.export.cypher.query(query :: STRING?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypher.schema,"apoc.export.cypher.schema(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypherAll,"apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypherData,"apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypherGraph,"apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.cypherQuery,"apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)"
apoc.export.graphml.all,"apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.graphml.data,"apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.graphml.graph,"apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.graphml.query,"apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.json.all,"apoc.export.json.all(file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.json.data,"apoc.export.json.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.json.graph,"apoc.export.json.graph(graph :: MAP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.export.json.query,"apoc.export.json.query(query :: STRING?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.generate.ba,"apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.complete,"apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.er,"apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.simple,"apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.ws,"apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID"
apoc.gephi.add,"apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty = null :: STRING?, exportproperties = [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.get.nodes,apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)
apoc.get.rels,apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)
apoc.graph.from,"apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromCypher,"apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromDB,"apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromData,"apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromDocument,"apoc.graph.fromDocument(json :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromPath,"apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromPaths,"apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.validateDocument,"apoc.graph.validateDocument(json :: ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.help,"apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?)"
apoc.import.csv,"apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.import.graphml,"apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.index.addAllNodes,"apoc.index.addAllNodes(index :: STRING?, structure :: MAP?, options = {} :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)"
apoc.index.addAllNodesExtended,"apoc.index.addAllNodesExtended(index :: STRING?, structure :: MAP?, options :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)"
apoc.index.addNode,"apoc.index.addNode(node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeByLabel,"apoc.index.addNodeByLabel(label :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeByName,"apoc.index.addNodeByName(name :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeMap,"apoc.index.addNodeMap(node :: NODE?, properties :: MAP?) :: VOID"
apoc.index.addNodeMapByName,"apoc.index.addNodeMapByName(index :: STRING?, node :: NODE?, properties :: MAP?) :: VOID"
apoc.index.addRelationship,"apoc.index.addRelationship(relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addRelationshipByName,"apoc.index.addRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addRelationshipMap,"apoc.index.addRelationshipMap(relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID"
apoc.index.addRelationshipMapByName,"apoc.index.addRelationshipMapByName(index :: STRING?, relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID"
apoc.index.between,"apoc.index.between(from :: NODE?, type :: STRING?, to :: NODE?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)"
apoc.index.forNodes,"apoc.index.forNodes(name :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.forRelationships,"apoc.index.forRelationships(name :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.in,"apoc.index.in(to :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.list,"apoc.index.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.nodes,"apoc.index.nodes(label :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.orderedByText,"apoc.index.orderedByText(label :: STRING?, key :: STRING?, operator :: STRING?, value :: STRING?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.orderedRange,"apoc.index.orderedRange(label :: STRING?, key :: STRING?, min :: ANY?, max :: ANY?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.out,"apoc.index.out(from :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.related,"apoc.index.related(nodes :: LIST? OF NODE?, label :: STRING?, key :: STRING?, relationship :: STRING?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.relationships,"apoc.index.relationships(type :: STRING?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)"
apoc.index.remove,"apoc.index.remove(name :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.removeNodeByName,"apoc.index.removeNodeByName(name :: STRING?, node :: NODE?) :: VOID"
apoc.index.removeRelationshipByName,"apoc.index.removeRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?) :: VOID"
apoc.index.search,"apoc.index.search(index :: STRING?, query :: STRING?, numberOfResults = 100 :: INTEGER?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.load.csv,"apoc.load.csv(url :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)"
apoc.load.driver,apoc.load.driver(driverClass :: STRING?) :: VOID
apoc.load.html,"apoc.load.html(url :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)"
apoc.load.jdbc,"apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.load.jdbcParams,"apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.load.jdbcUpdate,"apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.load.json,"apoc.load.json(url :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)"
apoc.load.jsonArray,"apoc.load.jsonArray(url :: STRING?, path =  :: STRING?) :: (value :: ANY?)"
apoc.load.jsonParams,"apoc.load.jsonParams(urlOrKey :: STRING?, headers :: MAP?, payload :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)"
apoc.load.ldap,"apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)"
apoc.load.xml,"apoc.load.xml(url :: STRING?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (value :: MAP?)"
apoc.load.xmlSimple,apoc.load.xmlSimple(url :: STRING?) :: (value :: MAP?)
apoc.lock.all,"apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID"
apoc.lock.nodes,apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID
apoc.lock.read.nodes,apoc.lock.read.nodes(nodes :: LIST? OF NODE?) :: VOID
apoc.lock.read.rels,apoc.lock.read.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID
apoc.lock.rels,apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID
apoc.log.debug,"apoc.log.debug(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.error,"apoc.log.error(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.info,"apoc.log.info(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.stream,"apoc.log.stream(path :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, line :: STRING?, path :: STRING?)"
apoc.log.warn,"apoc.log.warn(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.math.regr,"apoc.math.regr(label :: STRING?, propertyY :: STRING?, propertyX :: STRING?) :: (r2 :: FLOAT?, avgX :: FLOAT?, avgY :: FLOAT?, slope :: FLOAT?)"
apoc.merge.node,"apoc.merge.node(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)"
apoc.merge.node.eager,"apoc.merge.node.eager(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)"
apoc.merge.relationship,"apoc.merge.relationship(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)"
apoc.merge.relationship.eager,"apoc.merge.relationship.eager(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)"
apoc.meta.data,"apoc.meta.data(config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)"
apoc.meta.graph,"apoc.meta.graph(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.meta.graphSample,"apoc.meta.graphSample(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.meta.schema,apoc.meta.schema(config = {} :: MAP?) :: (value :: MAP?)
apoc.meta.stats,"apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, relTypesCount :: MAP?, stats :: MAP?)"
apoc.meta.subGraph,"apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.metrics.get,"apoc.metrics.get(metricName :: STRING?, config = {} :: MAP?) :: (timestamp :: INTEGER?, metric :: STRING?, map :: MAP?)"
apoc.metrics.list,"apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)"
apoc.metrics.storage,"apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)"
apoc.model.jdbc,"apoc.model.jdbc(jdbc :: STRING?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.mongodb.count,"apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)"
apoc.mongodb.delete,"apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)"
apoc.mongodb.find,"apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?) :: (value :: MAP?)"
apoc.mongodb.first,"apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = false :: BOOLEAN?) :: (value :: MAP?)"
apoc.mongodb.get,"apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?) :: (value :: MAP?)"
apoc.mongodb.insert,"apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID"
apoc.mongodb.update,"apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)"
apoc.monitor.ids,"apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)"
apoc.monitor.kernel,"apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)"
apoc.monitor.locks,"apoc.monitor.locks(minWaitTime :: INTEGER?) :: (advertedDeadLocks :: INTEGER?, lockCount :: INTEGER?, contendedLockCount :: INTEGER?, minimumWaitTimeMs :: INTEGER?, contendedLocks :: LIST? OF MAP?, info :: STRING?)"
apoc.monitor.store,"apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)"
apoc.monitor.tx,"apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)"
apoc.neighbors.athop,"apoc.neighbors.athop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)"
apoc.neighbors.athop.count,"apoc.neighbors.athop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)"
apoc.neighbors.byhop,"apoc.neighbors.byhop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (nodes :: LIST? OF NODE?)"
apoc.neighbors.byhop.count,"apoc.neighbors.byhop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: LIST? OF ANY?)"
apoc.neighbors.tohop,"apoc.neighbors.tohop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)"
apoc.neighbors.tohop.count,"apoc.neighbors.tohop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)"
apoc.nodes.collapse,"apoc.nodes.collapse(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)"
apoc.nodes.delete,"apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)"
apoc.nodes.get,apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)
apoc.nodes.group,"apoc.nodes.group(labels :: LIST? OF STRING?, groupByProperties :: LIST? OF STRING?, aggregations = [{*=count}, {*=count}] :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, node :: NODE?, relationship :: RELATIONSHIP?)"
apoc.nodes.link,"apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?) :: VOID"
apoc.nodes.rels,apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)
apoc.path.expand,"apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)"
apoc.path.expandConfig,"apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)"
apoc.path.spanningTree,"apoc.path.spanningTree(start :: ANY?, config :: MAP?) :: (path :: PATH?)"
apoc.path.subgraphAll,"apoc.path.subgraphAll(start :: ANY?, config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.path.subgraphNodes,"apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)"
apoc.periodic.cancel,"apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)"
apoc.periodic.commit,"apoc.periodic.commit(statement :: STRING?, params = {} :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, failedBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?, wasTerminated :: BOOLEAN?)"
apoc.periodic.countdown,"apoc.periodic.countdown(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)"
apoc.periodic.iterate,"apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?)"
apoc.periodic.list,"apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)"
apoc.periodic.repeat,"apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?, config = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)"
apoc.periodic.rock_n_roll,"apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?)"
apoc.periodic.rock_n_roll_while,"apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)"
apoc.periodic.submit,"apoc.periodic.submit(name :: STRING?, statement :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)"
apoc.refactor.categorize,"apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID"
apoc.refactor.cloneNodes,"apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?, withRelationships = false :: BOOLEAN?, skipProperties = [] :: LIST? OF STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)"
apoc.refactor.cloneNodesWithRelationships,"apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)"
apoc.refactor.cloneSubgraph,"apoc.refactor.cloneSubgraph(nodes :: LIST? OF NODE?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)"
apoc.refactor.cloneSubgraphFromPaths,"apoc.refactor.cloneSubgraphFromPaths(paths :: LIST? OF PATH?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)"
apoc.refactor.collapseNode,"apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)"
apoc.refactor.extractNode,"apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)"
apoc.refactor.from,"apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)"
apoc.refactor.invert,"apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)"
apoc.refactor.mergeNodes,"apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (node :: NODE?)"
apoc.refactor.mergeRelationships,"apoc.refactor.mergeRelationships(rels :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (rel :: RELATIONSHIP?)"
apoc.refactor.normalizeAsBoolean,"apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID"
apoc.refactor.rename.label,"apoc.refactor.rename.label(oldLabel :: STRING?, newLabel :: STRING?, nodes = [] :: LIST? OF NODE?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)"
apoc.refactor.rename.nodeProperty,"apoc.refactor.rename.nodeProperty(oldName :: STRING?, newName :: STRING?, nodes = [] :: LIST? OF ANY?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)"
apoc.refactor.rename.type,"apoc.refactor.rename.type(oldType :: STRING?, newType :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)"
apoc.refactor.rename.typeProperty,"apoc.refactor.rename.typeProperty(oldName :: STRING?, newName :: STRING?, rels = [] :: LIST? OF ANY?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)"
apoc.refactor.setType,"apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)"
apoc.refactor.to,"apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)"
apoc.schema.assert,"apoc.schema.assert(indexes :: MAP?, constraints :: MAP?, dropExisting = true :: BOOLEAN?) :: (label :: ANY?, key :: STRING?, keys :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)"
apoc.schema.nodes,"apoc.schema.nodes(config = {} :: MAP?) :: (name :: STRING?, label :: ANY?, properties :: LIST? OF STRING?, status :: STRING?, type :: STRING?, failure :: STRING?, populationProgress :: FLOAT?, size :: INTEGER?, valuesSelectivity :: FLOAT?, userDescription :: STRING?)"
apoc.schema.properties.distinct,"apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)"
apoc.schema.properties.distinctCount,"apoc.schema.properties.distinctCount(label =  :: STRING?, key =  :: STRING?) :: (label :: STRING?, key :: STRING?, value :: ANY?, count :: INTEGER?)"
apoc.schema.relationships,"apoc.schema.relationships(config = {} :: MAP?) :: (name :: STRING?, type :: STRING?, properties :: LIST? OF STRING?, status :: STRING?)"
apoc.search.multiSearchReduced,"apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)"
apoc.search.node,"apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)"
apoc.search.nodeAll,"apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)"
apoc.search.nodeAllReduced,"apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)"
apoc.search.nodeReduced,"apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)"
apoc.spatial.geocode,"apoc.spatial.geocode(location :: STRING?, maxResults = 100 :: INTEGER?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)"
apoc.spatial.geocodeOnce,"apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)"
apoc.spatial.reverseGeocode,"apoc.spatial.reverseGeocode(latitude :: FLOAT?, longitude :: FLOAT?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)"
apoc.spatial.sortByDistance,"apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)"
apoc.static.get,apoc.static.get(key :: STRING?) :: (value :: ANY?)
apoc.static.getAll,apoc.static.getAll(prefix :: STRING?) :: (value :: MAP?)
apoc.static.list,"apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)"
apoc.static.set,"apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)"
apoc.stats.degrees,"apoc.stats.degrees(types =  :: STRING?) :: (type :: STRING?, direction :: STRING?, total :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?)"
apoc.text.doubleMetaphone,apoc.text.doubleMetaphone(value :: ANY?) :: (value :: STRING?)
apoc.text.phonetic,apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)
apoc.text.phoneticDelta,"apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)"
apoc.trigger.add,"apoc.trigger.add(name :: STRING?, kernelTransaction :: STRING?, selector :: MAP?, config = {} :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.trigger.list,"apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.trigger.pause,"apoc.trigger.pause(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.trigger.remove,"apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.trigger.removeAll,"apoc.trigger.removeAll() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.trigger.resume,"apoc.trigger.resume(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)"
apoc.util.sleep,apoc.util.sleep(duration :: INTEGER?) :: VOID
apoc.util.validate,"apoc.util.validate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: VOID"
apoc.uuid.install,"apoc.uuid.install(label :: STRING?, config = {} :: MAP?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.list,"apoc.uuid.list() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.remove,"apoc.uuid.remove(label :: STRING?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.removeAll,"apoc.uuid.removeAll() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.warmup.run,"apoc.warmup.run(loadProperties = false :: BOOLEAN?, loadDynamicProperties = false :: BOOLEAN?, loadIndexes = false :: BOOLEAN?) :: (pageSize :: INTEGER?, totalTime :: INTEGER?, transactionWasTerminated :: BOOLEAN?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, relGroupsPerPage :: INTEGER?, relGroupsTotal :: INTEGER?, relGroupPages :: INTEGER?, relGroupsTime :: INTEGER?, propertiesLoaded :: BOOLEAN?, dynamicPropertiesLoaded :: BOOLEAN?, propsPerPage :: INTEGER?, propRecordsTotal :: INTEGER?, propPages :: INTEGER?, propsTime :: INTEGER?, stringPropsPerPage :: INTEGER?, stringPropRecordsTotal :: INTEGER?, stringPropPages :: INTEGER?, stringPropsTime :: INTEGER?, arrayPropsPerPage :: INTEGER?, arrayPropRecordsTotal :: INTEGER?, arrayPropPages :: INTEGER?, arrayPropsTime :: INTEGER?, indexesLoaded :: BOOLEAN?, indexPages :: INTEGER?, indexTime :: INTEGER?)"
apoc.when,"apoc.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)"
apoc.xml.import,"apoc.xml.import(url :: STRING?, config = {} :: MAP?) :: (node :: NODE?)"
db.awaitIndex,"db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID"
db.awaitIndexes,db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID
db.constraints,db.constraints() :: (description :: STRING?)
db.createIndex,"db.createIndex(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)"
db.createLabel,db.createLabel(newLabel :: STRING?) :: VOID
db.createNodeKey,"db.createNodeKey(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)"
db.createProperty,db.createProperty(newProperty :: STRING?) :: VOID
db.createRelationshipType,db.createRelationshipType(newRelationshipType :: STRING?) :: VOID
db.createUniquePropertyConstraint,"db.createUniquePropertyConstraint(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)"
db.index.explicit.addNode,"db.index.explicit.addNode(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)"
db.index.explicit.addRelationship,"db.index.explicit.addRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)"
db.index.explicit.auto.searchNodes,"db.index.explicit.auto.searchNodes(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)"
db.index.explicit.auto.searchRelationships,"db.index.explicit.auto.searchRelationships(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.auto.seekNodes,"db.index.explicit.auto.seekNodes(key :: STRING?, value :: ANY?) :: (node :: NODE?)"
db.index.explicit.auto.seekRelationships,"db.index.explicit.auto.seekRelationships(key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)"
db.index.explicit.drop,"db.index.explicit.drop(indexName :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.existsForNodes,db.index.explicit.existsForNodes(indexName :: STRING?) :: (success :: BOOLEAN?)
db.index.explicit.existsForRelationships,db.index.explicit.existsForRelationships(indexName :: STRING?) :: (success :: BOOLEAN?)
db.index.explicit.forNodes,"db.index.explicit.forNodes(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.forRelationships,"db.index.explicit.forRelationships(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.list,"db.index.explicit.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.removeNode,"db.index.explicit.removeNode(indexName :: STRING?, node :: NODE?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)"
db.index.explicit.removeRelationship,"db.index.explicit.removeRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)"
db.index.explicit.searchNodes,"db.index.explicit.searchNodes(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)"
db.index.explicit.searchRelationships,"db.index.explicit.searchRelationships(indexName :: STRING?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsBetween,"db.index.explicit.searchRelationshipsBetween(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsIn,"db.index.explicit.searchRelationshipsIn(indexName :: STRING?, in :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsOut,"db.index.explicit.searchRelationshipsOut(indexName :: STRING?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.seekNodes,"db.index.explicit.seekNodes(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?)"
db.index.explicit.seekRelationships,"db.index.explicit.seekRelationships(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)"
db.index.fulltext.awaitEventuallyConsistentIndexRefresh,db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID
db.index.fulltext.awaitIndex,"db.index.fulltext.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID"
db.index.fulltext.createNodeIndex,"db.index.fulltext.createNodeIndex(indexName :: STRING?, labels :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, config = {} :: MAP?) :: VOID"
db.index.fulltext.createRelationshipIndex,"db.index.fulltext.createRelationshipIndex(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, propertyNames :: LIST? OF STRING?, config = {} :: MAP?) :: VOID"
db.index.fulltext.drop,db.index.fulltext.drop(indexName :: STRING?) :: VOID
db.index.fulltext.listAvailableAnalyzers,"db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?)"
db.index.fulltext.queryNodes,"db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?)"
db.index.fulltext.queryRelationships,"db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?)"
db.indexes,"db.indexes() :: (description :: STRING?, indexName :: STRING?, tokenNames :: LIST? OF STRING?, properties :: LIST? OF STRING?, state :: STRING?, type :: STRING?, progress :: FLOAT?, provider :: MAP?, id :: INTEGER?, failureMessage :: STRING?)"
db.labels,db.labels() :: (label :: STRING?)
db.propertyKeys,db.propertyKeys() :: (propertyKey :: STRING?)
db.relationshipTypes,db.relationshipTypes() :: (relationshipType :: STRING?)
db.resampleIndex,db.resampleIndex(index :: STRING?) :: VOID
db.resampleOutdatedIndexes,db.resampleOutdatedIndexes() :: VOID
db.schema,"db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
db.schema.nodeTypeProperties,"db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)"
db.schema.relTypeProperties,"db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)"
db.schema.visualization,"db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
db.stats.clear,"db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
db.stats.collect,"db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
db.stats.retrieve,"db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)"
db.stats.retrieveAllAnonymized,"db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)"
db.stats.status,"db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?)"
db.stats.stop,"db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
dbms.changePassword,dbms.changePassword(password :: STRING?) :: VOID
dbms.checkpoint,"dbms.checkpoint() :: (success :: BOOLEAN?, message :: STRING?)"
db.clearQueryCaches,db.clearQueryCaches() :: (value :: STRING?)
dbms.components,"dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)"
dbms.functions,"dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?)"
dbms.functions,"dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?)"
dbms.getTXMetaData,dbms.getTXMetaData() :: (metadata :: MAP?)
dbms.killConnection,"dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killConnections,"dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killQueries,"dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killQuery,"dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killTransaction,"dbms.killTransaction(id :: STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killTransactions,"dbms.killTransactions(ids :: LIST? OF STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.listActiveLocks,"dbms.listActiveLocks(queryId :: STRING?) :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?)"
dbms.listConfig,"dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)"
dbms.listConnections,"dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?)"
dbms.listQueries,"dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, metaData :: MAP?, query :: STRING?, parameters :: MAP?, planner :: STRING?, runtime :: STRING?, indexes :: LIST? OF MAP?, startTime :: STRING?, elapsedTime :: STRING?, connectionDetails :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, status :: STRING?, resourceInformation :: MAP?, activeLockCount :: INTEGER?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?)"
dbms.listTransactions,"dbms.listTransactions() :: (transactionId :: STRING?, username :: STRING?, metaData :: MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, currentQueryId :: STRING?, currentQuery :: STRING?, activeLockCount :: INTEGER?, status :: STRING?, resourceInformation :: MAP?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, allocatedDirectBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?)"
dbms.procedures,"dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?)"
dbms.procedures,"dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, roles :: LIST? OF STRING?, mode :: STRING?)"
dbms.queryJmx,"dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)"
dbms.security.activateUser,"dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.addRoleToUser,"dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID"
dbms.security.changePassword,"dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID"
dbms.security.changeUserPassword,"dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.clearAuthCache,dbms.security.clearAuthCache() :: VOID
dbms.security.createRole,dbms.security.createRole(roleName :: STRING?) :: VOID
dbms.security.createUser,"dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.deleteRole,dbms.security.deleteRole(roleName :: STRING?) :: VOID
dbms.security.deleteUser,dbms.security.deleteUser(username :: STRING?) :: VOID
dbms.security.listRoles,"dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?)"
dbms.security.listRolesForUser,dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?)
dbms.security.listUsers,"dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
dbms.security.listUsersForRole,dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?)
dbms.security.removeRoleFromUser,"dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID"
dbms.security.showCurrentUser,"dbms.security.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
dbms.security.suspendUser,dbms.security.suspendUser(username :: STRING?) :: VOID
dbms.setConfigValue,"dbms.setConfigValue(setting :: STRING?, value :: STRING?) :: VOID"
dbms.setTXMetaData,dbms.setTXMetaData(data :: MAP?) :: VOID
dbms.showCurrentUser,"dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
