= Spatial Functions

The spatial procedures are intended to enable geographic capabilities on your data.

=== geocode

The first procedure _geocode_ which will convert a textual address
into a location containing _latitude_, _longitude_ and _description_. Despite being
only a single function, together with the built-in functions _point_ and _distance_
we can achieve quite powerful results.

First, how can we use the procedure:

[source,cypher]
----
CALL apoc.spatial.geocode('21 rue Paul Bellamy 44000 NANTES FRANCE') YIELD location
RETURN location.latitude, location.longitude // will return 47.2221667, -1.5566624
----

== Using Geocode within a bigger Cypher query

A more complex, or useful, example which geocodes addresses found in properties of nodes:

[source,cypher]
----
MATCH (a:Place)
WHERE exists(a.address)
CALL apoc.spatial.geocode(a.address) YIELD location
RETURN location.latitude AS latitude, location.longitude AS longitude, location.description AS description
----

== Calculating distance between locations

If we wish to calculate the distance between addresses, we need to use the point() function to convert
latitude and longitude to Cyper Point types, and then use the distance() function to calculate the distance:

[source,cypher]
----
WITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel
MATCH (a:Place)
WHERE exists(a.address)
CALL apoc.spatial.geocode(a.address) YIELD location
WITH location, distance(point(location), eiffel) AS distance
WHERE distance < 5000
RETURN location.description AS description, distance
ORDER BY distance
LIMIT 100
----

=== sortPathsByDistance

The second procedure enables you to sort a given collection of paths by the sum of their distance based on lat/long properties
on the nodes.

Sample data :

[source, cypher]
----
CREATE (bruges:City {name:"bruges", latitude: 51.2605829, longitude: 3.0817189})
CREATE (brussels:City {name:"brussels", latitude: 50.854954, longitude: 4.3051786})
CREATE (paris:City {name:"paris", latitude: 48.8588376, longitude: 2.2773455})
CREATE (dresden:City {name:"dresden", latitude: 51.0767496, longitude: 13.6321595})
MERGE (bruges)-[:NEXT]->(brussels)
MERGE (brussels)-[:NEXT]->(dresden)
MERGE (brussels)-[:NEXT]->(paris)
MERGE (bruges)-[:NEXT]->(paris)
MERGE (paris)-[:NEXT]->(dresden)
----

Finding paths and sort them by distance

[source, cypher]
----
MATCH (a:City {name:'bruges'}), (b:City {name:'dresden'})
MATCH p=(a)-[*]->(b)
WITH collect(p) as paths
CALL apoc.spatial.sortPathsByDistance(paths) YIELD path, distance
RETURN path, distance
----

== Graph Refactoring

In order not to have to repeatedly geocode the same thing in multiple queries, especially
if the database will be used by many people, it might be a good idea to persist the results
in the database so that subsequent calls can use the saved results.

Geocode and persist the result

[source,cypher]
----
MATCH (a:Place)
WHERE exists(a.address) AND NOT exists(a.latitude)
WITH a LIMIT 1000
CALL apoc.spatial.geocode(a.address) YIELD location
SET a.latitude = location.latitude
SET a.longitude = location.longitude
----

Note that the above command only geocodes the first 1000 ‘Place’ nodes that have not already been geocoded.
This query can be run multiple times until all places are geocoded. Why would we want to do this?
Two good reasons:

* The geocoding service is a public service that can throttle or blacklist sites that hit the service too heavily, so controlling how much we do is useful.
* The transaction is updating the database, and it is wise not to update the database with too many things in the same transaction, to avoid using up too much memory. This trick will keep the memory usage very low.

Now make use of the results in distance queries


[source,cypher]
----
WITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel
MATCH (a:Place)
WHERE exists(a.latitude) AND exists(a.longitude)
WITH a, distance(point(a), eiffel) AS distance
WHERE distance < 5000
RETURN a.name, distance
ORDER BY distance
LIMIT 100
----

== Combined Space and Time search

Combining spatial and date-time procedures can allow for more complex queries:

[source,cypher]
----
CALL apoc.date.parse('2016-06-01 00:00:00','h') YIELD value AS due_date
WITH due_date,
point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel
MATCH (e:Event)
WHERE exists(e.address) AND exists(e.datetime)
CALL apoc.spatial.geocode(e.address) YIELD value AS location
CALL apoc.date.parse(e.datetime,'h') YIELD value AS hours
WITH e, location,
distance(point(location), eiffel) AS distance,
            (due_date - hours)/24.0 AS days_before_due
WHERE distance < 5000 AND days_before_due < 14 AND hours < due_date
RETURN e.name AS event, e.datetime AS date,
location.description AS description, distance
ORDER BY distance
----

