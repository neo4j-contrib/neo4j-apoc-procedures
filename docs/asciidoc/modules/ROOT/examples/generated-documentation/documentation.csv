¦type¦qualified name¦signature¦description¦core¦documentation
¦procedure¦apoc.algo.aStar¦apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)¦apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.algo.aStarConfig¦apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)¦apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat'}) YIELD path, weight - run A* with relationship property name as cost function¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.algo.allSimplePaths¦apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)¦apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.algo.cover¦apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)¦apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.algo.dijkstra¦apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight = NaN :: FLOAT?, numberOfWantedPaths = 1 :: INTEGER?) :: (path :: PATH?, weight :: FLOAT?)¦apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.algo.dijkstraWithDefaultWeight¦apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)¦apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist¦true¦xref::algorithms/path-finding-procedures.adoc
¦procedure¦apoc.atomic.add¦apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.add(node/relatonship,propertyName,number) Sums the property's value with the 'number' value ¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.atomic.concat¦apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property's value with the 'string' value¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.atomic.insert¦apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property's array value at 'position'¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.atomic.remove¦apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position 'position'¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.atomic.subtract¦apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the 'number' value to the property's value¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.atomic.update¦apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)¦apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property's value with a cypher operation (ex. "n.prop1+n.prop2")¦true¦xref::graph-updates/atomic-updates.adoc
¦procedure¦apoc.bolt.execute¦apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)¦apoc.bolt.execute(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for reads and writes¦true¦xref::database-integration/bolt-neo4j.adoc
¦procedure¦apoc.bolt.load¦apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)¦apoc.bolt.load(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read¦true¦xref::database-integration/bolt-neo4j.adoc
¦procedure¦apoc.bolt.load.fromLocal¦apoc.bolt.load.fromLocal(url :: STRING?, localStatement :: STRING?, remoteStatement :: STRING?, config = {} :: MAP?) :: (row :: MAP?)¦¦true¦xref::database-integration/bolt-neo4j.adoc
¦procedure¦apoc.case¦apoc.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)¦apoc.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / read-only query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters¦true¦xref::cypher-execution/conditionals.adoc
¦procedure¦apoc.cluster.graph¦apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦¦false¦
¦procedure¦apoc.coll.elements¦apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)¦apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type¦true¦
¦procedure¦apoc.coll.pairWithOffset¦apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (value :: LIST? OF ANY?)¦apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset¦true¦
¦procedure¦apoc.coll.partition¦apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)¦apoc.coll.partition(list,batchSize)¦true¦
¦procedure¦apoc.coll.split¦apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)¦apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists¦true¦
¦procedure¦apoc.coll.zipToRows¦apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)¦apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair¦true¦
¦procedure¦apoc.config.list¦apoc.config.list() :: (key :: STRING?, value :: ANY?)¦apoc.config.list | Lists the Neo4j configuration as key,value table¦false¦xref::database-introspection/config.adoc
¦procedure¦apoc.config.map¦apoc.config.map() :: (value :: MAP?)¦apoc.config.map | Lists the Neo4j configuration as map¦false¦xref::database-introspection/config.adoc
¦procedure¦apoc.convert.setJsonProperty¦apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID¦apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node¦true¦
¦procedure¦apoc.convert.toTree¦apoc.convert.toTree(paths :: LIST? OF PATH?, lowerCaseRels = true :: BOOLEAN?, config = {} :: MAP?) :: (value :: MAP?)¦apoc.convert.toTree([paths],[lowerCaseRels=true], [config]) creates a stream of nested documents representing the at least one root of these paths¦true¦
¦procedure¦apoc.couchbase.append¦apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.append(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.exists¦apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)¦apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.get¦apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.insert¦apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.insert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.namedParamsQuery¦apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)¦apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.posParamsQuery¦apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)¦apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.prepend¦apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.prepend(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.query¦apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)¦apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.remove¦apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.remove(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.replace¦apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.couchbase.upsert¦apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)¦apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.¦false¦xref::database-integration/couchbase.adoc
¦procedure¦apoc.create.addLabels¦apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)¦apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes¦true¦
¦procedure¦apoc.create.node¦apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)¦apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.nodes¦apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)¦apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.relationship¦apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)¦apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.removeLabels¦apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)¦apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.removeProperties¦apoc.create.removeProperties(nodes :: ANY?, keys :: LIST? OF STRING?) :: (node :: NODE?)¦apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given properties from the nodes(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.removeRelProperties¦apoc.create.removeRelProperties(rels :: ANY?, keys :: LIST? OF STRING?) :: (rel :: RELATIONSHIP?)¦apoc.create.removeRelProperties( [rel,id,ids,rels], [keys]) - removes the given properties from the relationship(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.setLabels¦apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)¦apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes¦true¦
¦procedure¦apoc.create.setProperties¦apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)¦apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given properties on the nodes(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.setProperty¦apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)¦apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.setRelProperties¦apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)¦apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given properties on the relationship(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.setRelProperty¦apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)¦apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.create.uuids¦apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)¦apoc.create.uuids(count) yield uuid - creates 'count' UUIDs ¦true¦
¦procedure¦apoc.create.vNode¦apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)¦apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.create.vNodes¦apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)¦apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.create.vPattern¦apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)¦apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.create.vPatternFull¦apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)¦apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.create.vRelationship¦apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)¦apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.create.virtualPath¦apoc.create.virtualPath(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)¦apoc.create.virtualPath(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual path of nodes joined by a relationship and the associated properties¦true¦xref::virtual/virtual-nodes-rels.adoc
¦procedure¦apoc.custom.asFunction¦apoc.custom.asFunction(name :: STRING?, statement :: STRING?, outputs =  :: STRING?, inputs = null :: LIST? OF LIST? OF STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID¦apoc.custom.asFunction(name, statement, outputs, inputs, forceSingle, description) - register a custom cypher function¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.asProcedure¦apoc.custom.asProcedure(name :: STRING?, statement :: STRING?, mode = read :: STRING?, outputs = null :: LIST? OF LIST? OF STRING?, inputs = null :: LIST? OF LIST? OF STRING?, description =  :: STRING?) :: VOID¦apoc.custom.asProcedure(name, statement, mode, outputs, inputs, description) - register a custom cypher procedure¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.declareFunction¦apoc.custom.declareFunction(signature :: STRING?, statement :: STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID¦apoc.custom.declareFunction(signature, statement, forceSingle, description) - register a custom cypher function¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.declareProcedure¦apoc.custom.declareProcedure(signature :: STRING?, statement :: STRING?, mode = read :: STRING?, description =  :: STRING?) :: VOID¦apoc.custom.declareProcedure(signature, statement, mode, description) - register a custom cypher procedure¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.list¦apoc.custom.list() :: (type :: STRING?, name :: STRING?, description :: STRING?, mode :: STRING?, statement :: STRING?, inputs :: LIST? OF LIST? OF STRING?, outputs :: ANY?, forceSingle :: BOOLEAN?)¦apoc.custom.list() - provide a list of custom procedures/function registered¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.removeFunction¦apoc.custom.removeFunction(name :: STRING?) :: VOID¦apoc.custom.removeFunction(name, type) - remove the targeted custom function¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.custom.removeProcedure¦apoc.custom.removeProcedure(name :: STRING?) :: VOID¦apoc.custom.removeProcedure(name) - remove the targeted custom procedure¦false¦xref::cypher-execution/cypher-based-procedures-functions.adoc
¦procedure¦apoc.cypher.doIt¦apoc.cypher.doIt(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)¦apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.mapParallel¦apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)¦apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.mapParallel2¦apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout = 10 :: INTEGER?) :: (value :: MAP?)¦apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.parallel¦apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)¦¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.parallel2¦apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)¦¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.run¦apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)¦apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters - currently no schema operations¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runFile¦apoc.cypher.runFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)¦apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runFiles¦apoc.cypher.runFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)¦apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runMany¦apoc.cypher.runMany(cypher :: STRING?, params :: MAP?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)¦apoc.cypher.runMany('cypher;\nstatements;',\{params},[{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runSchema¦apoc.cypher.runSchema(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)¦apoc.cypher.runSchema(statement, params) yield value - executes query schema statement with the given parameters¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runSchemaFile¦apoc.cypher.runSchemaFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)¦apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runSchemaFiles¦apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)¦apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated¦false¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runTimeboxed¦apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)¦apoc.cypher.runTimeboxed('cypherStatement',\{params}, timeout) - abort kernelTransaction after timeout ms if not finished¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.cypher.runWrite¦apoc.cypher.runWrite(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)¦apoc.cypher.runWrite(statement, params) yield value - alias for apoc.cypher.doIt¦true¦xref::cypher-execution/index.adoc
¦procedure¦apoc.date.expire¦apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID¦CALL apoc.date.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property¦false¦
¦procedure¦apoc.date.expireIn¦apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID¦CALL apoc.date.expireIn(node,time,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property¦false¦
¦procedure¦apoc.do.case¦apoc.do.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)¦apoc.do.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / writing query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters¦true¦xref::cypher-execution/conditionals.adoc
¦procedure¦apoc.do.when¦apoc.do.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)¦apoc.do.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes writing ifQuery or elseQuery with the given parameters¦true¦xref::cypher-execution/conditionals.adoc
¦procedure¦apoc.es.get¦apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)¦apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.getRaw¦apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)¦apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.post¦apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)¦apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.postRaw¦apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)¦apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.put¦apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)¦apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.query¦apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)¦apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.es.stats¦apoc.es.stats(host :: STRING?) :: (value :: MAP?)¦apoc.es.stats(host-url-Key) - elastic search statistics¦false¦xref::database-integration/elasticsearch.adoc
¦procedure¦apoc.example.movies¦apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.example.movies() | Creates the sample movies graph¦true¦
¦procedure¦apoc.export.csv.all¦apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.csv.all(file,config) - exports whole database as csv to the provided file¦true¦xref::export/csv.adoc
¦procedure¦apoc.export.csv.data¦apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file¦true¦xref::export/csv.adoc
¦procedure¦apoc.export.csv.graph¦apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.csv.graph(graph,file,config) - exports given graph object as csv to the provided file¦true¦xref::export/csv.adoc
¦procedure¦apoc.export.csv.query¦apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.csv.query(query,file,{config,...,params:\{params}}) - exports results from the cypher statement as csv to the provided file¦true¦xref::export/csv.adoc
¦procedure¦apoc.export.cypher.all¦apoc.export.cypher.all(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypher.data¦apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypher.graph¦apoc.export.cypher.graph(graph :: MAP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypher.query¦apoc.export.cypher.query(query :: STRING?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypher.schema¦apoc.export.cypher.schema(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypher.schema(file,config) - exports all schema indexes and constraints to cypher¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypherAll¦apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypherData¦apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypherGraph¦apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.cypherQuery¦apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: STRING?, nodeStatements :: STRING?, relationshipStatements :: STRING?, schemaStatements :: STRING?, cleanupStatements :: STRING?)¦apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file¦true¦xref::export/cypher.adoc
¦procedure¦apoc.export.graphml.all¦apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file¦true¦xref::export/graphml.adoc
¦procedure¦apoc.export.graphml.data¦apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file¦true¦xref::export/graphml.adoc
¦procedure¦apoc.export.graphml.graph¦apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file¦true¦xref::export/graphml.adoc
¦procedure¦apoc.export.graphml.query¦apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file¦true¦xref::export/graphml.adoc
¦procedure¦apoc.export.json.all¦apoc.export.json.all(file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.json.all(file,config) - exports whole database as json to the provided file¦true¦xref::export/json.adoc
¦procedure¦apoc.export.json.data¦apoc.export.json.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.json.data(nodes,rels,file,config) - exports given nodes and relationships as json to the provided file¦true¦xref::export/json.adoc
¦procedure¦apoc.export.json.graph¦apoc.export.json.graph(graph :: MAP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.json.graph(graph,file,config) - exports given graph object as json to the provided file¦true¦xref::export/json.adoc
¦procedure¦apoc.export.json.query¦apoc.export.json.query(query :: STRING?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.json.query(query,file,{config,...,params:\{params}}) - exports results from the cypher statement as json to the provided file¦true¦xref::export/json.adoc
¦procedure¦apoc.export.xls.all¦apoc.export.xls.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.xls.all(file,config) - exports whole database as xls to the provided file¦false¦
¦procedure¦apoc.export.xls.data¦apoc.export.xls.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.xls.data(nodes,rels,file,config) - exports given nodes and relationships as xls to the provided file¦false¦
¦procedure¦apoc.export.xls.graph¦apoc.export.xls.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.xls.graph(graph,file,config) - exports given graph object as xls to the provided file¦false¦
¦procedure¦apoc.export.xls.query¦apoc.export.xls.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.export.xls.query(query,file,{config,...,params:\{params}}) - exports results from the cypher statement as xls to the provided file¦false¦
¦procedure¦apoc.generate.ba¦apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID¦apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model¦false¦xref::graph-updates/graph-generators.adoc
¦procedure¦apoc.generate.complete¦apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID¦apoc.generate.complete(noNodes, label, type) - generates a random complete graph¦false¦xref::graph-updates/graph-generators.adoc
¦procedure¦apoc.generate.er¦apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID¦apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model¦false¦xref::graph-updates/graph-generators.adoc
¦procedure¦apoc.generate.simple¦apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID¦apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution¦false¦xref::graph-updates/graph-generators.adoc
¦procedure¦apoc.generate.ws¦apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID¦apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model¦false¦xref::graph-updates/graph-generators.adoc
¦procedure¦apoc.gephi.add¦apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty = null :: STRING?, exportproperties = [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.gephi.add(url-or-key, workspace, data, weightproperty, ['exportproperty']) | streams passed in data to Gephi¦false¦xref::export/gephi.adoc
¦procedure¦apoc.get.nodes¦apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)¦apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's¦false¦
¦procedure¦apoc.get.rels¦apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)¦apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's¦false¦
¦procedure¦apoc.graph.from¦apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.from(data,'name',\{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromCypher¦apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromCypher('kernelTransaction',\{params},'name',\{properties}) - creates a virtual graph object for later processing¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromDB¦apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromDB('name',\{properties}) - creates a virtual graph object for later processing¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromData¦apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromData([nodes],[relationships],'name',\{properties}) | creates a virtual graph object for later processing¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromDocument¦apoc.graph.fromDocument(json :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromDocument(\{json}, \{config}) yield graph - transform JSON documents into graph structures¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromPath¦apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromPaths(path,'name',\{properties}) - creates a virtual graph object for later processing¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.fromPaths¦apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)¦apoc.graph.fromPaths([paths],'name',\{properties}) - creates a virtual graph object for later processing¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.graph.validateDocument¦apoc.graph.validateDocument(json :: ANY?, config = {} :: MAP?) :: (row :: MAP?)¦apoc.graph.validateDocument(\{json}, \{config}) yield row - validates the json, return the result of the validation¦true¦xref::virtual/virtual-graph.adoc
¦procedure¦apoc.help¦apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?, core :: BOOLEAN?)¦Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.¦true¦
¦procedure¦apoc.import.csv¦apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.import.csv(nodes, relationships, config) - imports nodes and relationships from the provided CSV files with given labels and types¦true¦
¦procedure¦apoc.import.graphml¦apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.import.graphml(file,config) - imports graphml file¦true¦
¦procedure¦apoc.import.json¦apoc.import.json(file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)¦apoc.import.json(file,config) - imports the json list to the provided file¦true¦xref::import/load-json.adoc
¦procedure¦apoc.import.xml¦apoc.import.xml(url :: STRING?, config = {} :: MAP?) :: (node :: NODE?)¦apoc.import.xml(file,config) - imports graph from provided file¦true¦
¦procedure¦apoc.load.csv¦apoc.load.csv(url :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)¦apoc.load.csv('url',\{config}) YIELD lineNo, list, map - load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}¦false¦xref::import/load-csv.adoc
¦procedure¦apoc.load.csvParams¦apoc.load.csvParams(url :: STRING?, httpHeaders :: MAP?, payload :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)¦apoc.load.csvParams('url', {httpHeader: value}, payload, \{config}) YIELD lineNo, list, map - load from CSV URL (e.g. web-api) while sending headers / payload to load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}¦false¦
¦procedure¦apoc.load.directory¦apoc.load.directory(pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (value :: STRING?)¦apoc.load.directory('pattern', 'urlDir', \{config}) YIELD value - Loads list of all files in folder specified by urlDir or in import folder if urlDir string is empty or not specified¦false¦
¦procedure¦apoc.load.directory.async.add¦apoc.load.directory.async.add(name :: STRING?, cypher :: STRING?, pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)¦apoc.load.directory.async.add(name, cypher, pattern, urlDir, {}) YIELD name, status, pattern, cypher, urlDir, config, error - Add or replace a folder listener with a specific name, pattern and url directory that execute the specified cypher query when an event is triggered and return listener list¦true¦
¦procedure¦apoc.load.directory.async.list¦apoc.load.directory.async.list() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)¦apoc.load.directory.async.list() YIELD name, status, pattern, cypher, urlDir, config, error - List of all folder listeners¦true¦
¦procedure¦apoc.load.directory.async.remove¦apoc.load.directory.async.remove(name :: STRING?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)¦apoc.load.directory.async.remove(name) YIELD name, status, pattern, cypher, urlDir, config, error - Remove a folder listener by name and return remaining listeners, if any¦true¦
¦procedure¦apoc.load.directory.async.removeAll¦apoc.load.directory.async.removeAll() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)¦apoc.load.directory.async.removeAll() - Remove all folder listeners¦true¦
¦procedure¦apoc.load.driver¦apoc.load.driver(driverClass :: STRING?) :: VOID¦apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database¦false¦
¦procedure¦apoc.load.html¦apoc.load.html(url :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)¦apoc.load.html('url',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map¦false¦
¦procedure¦apoc.load.jdbc¦apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)¦apoc.load.jdbc('key or url','table or statement', params, config) YIELD row - load from relational database, from a full table or a sql statement¦false¦xref::database-integration/load-jdbc.adoc
¦procedure¦apoc.load.jdbcParams¦apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)¦deprecated - please use: apoc.load.jdbc('key or url','',[params]) YIELD row - load from relational database, from a sql statement with parameters¦false¦xref::database-integration/load-jdbc.adoc
¦procedure¦apoc.load.jdbcUpdate¦apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)¦apoc.load.jdbcUpdate('key or url','statement',[params],config) YIELD row - update relational database, from a SQL statement with optional parameters¦false¦xref::database-integration/load-jdbc.adoc
¦procedure¦apoc.load.json¦apoc.load.json(url :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)¦apoc.load.json('url',path, config) YIELD value -  import JSON as stream of values if the JSON was an array or a single value if it was a map¦true¦xref::import/load-json.adoc
¦procedure¦apoc.load.jsonArray¦apoc.load.jsonArray(url :: STRING?, path =  :: STRING?) :: (value :: ANY?)¦apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values¦true¦xref::import/load-json.adoc
¦procedure¦apoc.load.jsonParams¦apoc.load.jsonParams(urlOrKey :: STRING?, headers :: MAP?, payload :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)¦apoc.load.jsonParams('url',{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map¦true¦xref::import/load-json.adoc
¦procedure¦apoc.load.ldap¦apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)¦apoc.load.ldap("key" or \{connectionMap},\{searchMap}) Load entries from an ldap source (yield entry)¦false¦
¦procedure¦apoc.load.xls¦apoc.load.xls(url :: STRING?, selector :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, map :: MAP?)¦apoc.load.xls('url','selector',\{config}) YIELD lineNo, list, map - load XLS fom URL as stream of row values,
 config contains any of: {skip:1,limit:5,header:false,ignore:['tmp'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false, dateFormat:'iso_date', dateParse:['dd-MM-yyyy']}}¦false¦
¦procedure¦apoc.load.xml¦apoc.load.xml(url :: STRING?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (value :: MAP?)¦apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name - load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.¦true¦xref::import/xml.adoc
¦procedure¦apoc.load.xmlSimple¦apoc.load.xmlSimple(url :: STRING?) :: (value :: MAP?)¦apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name - load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.¦true¦xref::import/xml.adoc
¦procedure¦apoc.lock.all¦apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID¦apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships¦true¦xref::graph-updates/locking.adoc
¦procedure¦apoc.lock.nodes¦apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID¦apoc.lock.nodes([nodes]) acquires a write lock on the given nodes¦true¦xref::graph-updates/locking.adoc
¦procedure¦apoc.lock.read.nodes¦apoc.lock.read.nodes(nodes :: LIST? OF NODE?) :: VOID¦apoc.lock.read.nodes([nodes]) acquires a read lock on the given nodes¦true¦xref::graph-updates/locking.adoc
¦procedure¦apoc.lock.read.rels¦apoc.lock.read.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID¦apoc.lock.read.rels([relationships]) acquires a read lock on the given relationship¦true¦xref::graph-updates/locking.adoc
¦procedure¦apoc.lock.rels¦apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID¦apoc.lock.rels([relationships]) acquires a write lock on the given relationship¦true¦xref::graph-updates/locking.adoc
¦procedure¦apoc.log.debug¦apoc.log.debug(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID¦apoc.log.debug(message, params) - logs debug message¦false¦
¦procedure¦apoc.log.error¦apoc.log.error(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID¦apoc.log.error(message, params) - logs error message¦false¦
¦procedure¦apoc.log.info¦apoc.log.info(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID¦apoc.log.info(message, params) - logs info message¦false¦
¦procedure¦apoc.log.stream¦apoc.log.stream(path :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, line :: STRING?, path :: STRING?)¦apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines¦true¦
¦procedure¦apoc.log.warn¦apoc.log.warn(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID¦apoc.log.warn(message, params) - logs warn message¦false¦
¦procedure¦apoc.math.regr¦apoc.math.regr(label :: STRING?, propertyY :: STRING?, propertyX :: STRING?) :: (r2 :: FLOAT?, avgX :: FLOAT?, avgY :: FLOAT?, slope :: FLOAT?)¦apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label¦true¦xref::mathematical/math-functions.adoc
¦procedure¦apoc.merge.node¦apoc.merge.node(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)¦"apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes with dynamic labels, with support for setting properties ON CREATE or ON MATCH¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.merge.node.eager¦apoc.merge.node.eager(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)¦apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes eagerly, with dynamic labels, with support for setting properties ON CREATE or ON MATCH¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.merge.relationship¦apoc.merge.relationship(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)¦apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.merge.relationship.eager¦apoc.merge.relationship.eager(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)¦apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.meta.data¦apoc.meta.data(config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)¦apoc.meta.data(\{config})  - examines a subset of the graph to provide a tabular meta information¦true¦
¦procedure¦apoc.meta.data.of¦apoc.meta.data.of(graph :: ANY?, config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)¦apoc.meta.data.of(\{graph}, \{config})  - examines a subset of the graph to provide a tabular meta information¦true¦
¦procedure¦apoc.meta.graph¦apoc.meta.graph(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.meta.graph - examines the full graph to create the meta-graph¦true¦
¦procedure¦apoc.meta.graph.of¦apoc.meta.graph.of(graph = {} :: ANY?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.meta.graph.of(\{graph}, \{config})  - examines a subset of the graph to provide a graph meta information¦true¦
¦procedure¦apoc.meta.graphSample¦apoc.meta.graphSample(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships¦true¦
¦procedure¦apoc.meta.nodeTypeProperties¦apoc.meta.nodeTypeProperties(config = {} :: MAP?) :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)¦apoc.meta.nodeTypeProperties()¦true¦
¦procedure¦apoc.meta.relTypeProperties¦apoc.meta.relTypeProperties(config = {} :: MAP?) :: (relType :: STRING?, sourceNodeLabels :: LIST? OF STRING?, targetNodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)¦apoc.meta.relTypeProperties()¦true¦
¦procedure¦apoc.meta.schema¦apoc.meta.schema(config = {} :: MAP?) :: (value :: MAP?)¦apoc.meta.schema(\{config})  - examines a subset of the graph to provide a map-like meta information¦true¦
¦procedure¦apoc.meta.stats¦apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, relTypesCount :: MAP?, stats :: MAP?)¦apoc.meta.stats yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics¦true¦
¦procedure¦apoc.meta.subGraph¦apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph¦true¦
¦procedure¦apoc.metrics.get¦apoc.metrics.get(metricName :: STRING?, config = {} :: MAP?) :: (timestamp :: INTEGER?, metric :: STRING?, map :: MAP?)¦apoc.metrics.get(metricName, {}) - retrieve a system metric by its metric name. Additional configuration options may be passed matching the options available for apoc.load.csv.¦false¦
¦procedure¦apoc.metrics.list¦apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)¦apoc.metrics.list() - get a list of available metrics¦false¦
¦procedure¦apoc.metrics.storage¦apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)¦apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as 'dbms.directories.data'.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are **not** paths, they are a neo4j.conf setting key name¦false¦
¦procedure¦apoc.model.jdbc¦apoc.model.jdbc(jdbc :: STRING?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.model.jdbc('key or url', {schema:'<schema>', write: <true/false>, filters: { tables:[], views: [], columns: []}) YIELD nodes, relationships - load schema from relational database¦false¦xref::database-integration/database-modeling.adoc
¦procedure¦apoc.mongodb.count¦apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)¦apoc.mongodb.count(host-or-key,db,collection,query) yield value - perform a find operation on mongodb collection¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.delete¦apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)¦apoc.mongodb.delete(host-or-key,db,collection,query) - delete the given documents from the mongodb collection and returns the number of affected documents¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.find¦apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)¦apoc.mongodb.find(host-or-key,db,collection,query,projection,sort,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find,project,sort operation on mongodb collection¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.first¦apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = true :: BOOLEAN?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)¦apoc.mongodb.first(host-or-key,db,collection,query,[compatibleValues=false|true],[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a first operation on mongodb collection¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.get¦apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)¦apoc.mongodb.get(host-or-key,db,collection,query,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find operation on mongodb collection¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.get.byObjectId¦apoc.mongodb.get.byObjectId(host :: STRING?, db :: STRING?, collection :: STRING?, objectIdValue :: STRING?, config = {} :: MAP?) :: (value :: MAP?)¦apoc.mongodb.get.byObjectId(hostOrKey, db, collection, objectIdValue, config(default:{})) - get the document by Object id value¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.insert¦apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID¦apoc.mongodb.insert(host-or-key,db,collection,documents) - inserts the given documents into the mongodb collection¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.mongodb.update¦apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)¦apoc.mongodb.update(host-or-key,db,collection,query,update) - updates the given documents from the mongodb collection and returns the number of affected documents¦false¦xref::database-integration/mongodb.adoc
¦procedure¦apoc.monitor.ids¦apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)¦apoc.monitor.ids() returns the object ids in use for this neo4j instance¦true¦xref::database-introspection/monitoring.adoc
¦procedure¦apoc.monitor.kernel¦apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)¦apoc.monitor.kernel() returns informations about the neo4j kernel¦true¦xref::database-introspection/monitoring.adoc
¦procedure¦apoc.monitor.store¦apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)¦apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store¦true¦xref::database-introspection/monitoring.adoc
¦procedure¦apoc.monitor.tx¦apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)¦apoc.monitor.tx() returns informations about the neo4j transaction manager¦true¦xref::database-introspection/monitoring.adoc
¦procedure¦apoc.neighbors.athop¦apoc.neighbors.athop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)¦apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.neighbors.athop.count¦apoc.neighbors.athop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)¦apoc.neighbors.athop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.neighbors.byhop¦apoc.neighbors.byhop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (nodes :: LIST? OF NODE?)¦apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.neighbors.byhop.count¦apoc.neighbors.byhop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: LIST? OF ANY?)¦apoc.neighbors.byhop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.neighbors.tohop¦apoc.neighbors.tohop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)¦apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.neighbors.tohop.count¦apoc.neighbors.tohop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)¦apoc.neighbors.tohop.count(node, rel-direction-pattern, distance) - returns distinct count of nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/neighborhood.adoc
¦procedure¦apoc.nlp.aws.entities.graph¦apoc.nlp.aws.entities.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) entity graph for provided text¦false¦
¦procedure¦apoc.nlp.aws.entities.stream¦apoc.nlp.aws.entities.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Returns a stream of entities for provided text¦false¦
¦procedure¦apoc.nlp.aws.keyPhrases.graph¦apoc.nlp.aws.keyPhrases.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) key phrases graph for provided text¦false¦
¦procedure¦apoc.nlp.aws.keyPhrases.stream¦apoc.nlp.aws.keyPhrases.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Returns a stream of key phrases for provided text¦false¦
¦procedure¦apoc.nlp.aws.sentiment.graph¦apoc.nlp.aws.sentiment.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) sentiment graph for provided text¦false¦
¦procedure¦apoc.nlp.aws.sentiment.stream¦apoc.nlp.aws.sentiment.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Returns stream of sentiment for items in provided text¦false¦
¦procedure¦apoc.nlp.azure.entities.graph¦apoc.nlp.azure.entities.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) entity graph for provided text¦true¦
¦procedure¦apoc.nlp.azure.entities.stream¦apoc.nlp.azure.entities.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Provides a entity analysis for provided text¦true¦
¦procedure¦apoc.nlp.azure.keyPhrases.graph¦apoc.nlp.azure.keyPhrases.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) key phrase graph for provided text¦true¦
¦procedure¦apoc.nlp.azure.keyPhrases.stream¦apoc.nlp.azure.keyPhrases.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Provides a entity analysis for provided text¦true¦
¦procedure¦apoc.nlp.azure.sentiment.graph¦apoc.nlp.azure.sentiment.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) sentiment graph for provided text¦true¦
¦procedure¦apoc.nlp.azure.sentiment.stream¦apoc.nlp.azure.sentiment.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Provides a sentiment analysis for provided text¦true¦
¦procedure¦apoc.nlp.gcp.classify.graph¦apoc.nlp.gcp.classify.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Classifies a document into categories.¦false¦
¦procedure¦apoc.nlp.gcp.classify.stream¦apoc.nlp.gcp.classify.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Classifies a document into categories.¦false¦
¦procedure¦apoc.nlp.gcp.entities.graph¦apoc.nlp.gcp.entities.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)¦Creates a (virtual) entity graph for provided text¦false¦
¦procedure¦apoc.nlp.gcp.entities.stream¦apoc.nlp.gcp.entities.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)¦Returns a stream of entities for provided text¦false¦
¦procedure¦apoc.nodes.collapse¦apoc.nodes.collapse(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)¦apoc.nodes.collapse([nodes...],[{properties:'overwrite' or 'discard' or 'combine'}]) yield from, rel, to merge nodes onto first in list¦true¦xref::graph-querying/node-querying.adoc
¦procedure¦apoc.nodes.delete¦apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)¦apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these ids¦true¦xref::graph-querying/node-querying.adoc
¦procedure¦apoc.nodes.get¦apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)¦apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these ids¦true¦xref::graph-querying/node-querying.adoc
¦procedure¦apoc.nodes.group¦apoc.nodes.group(labels :: LIST? OF STRING?, groupByProperties :: LIST? OF STRING?, aggregations = [{*=count}, {*=count}] :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, node :: NODE?, relationship :: RELATIONSHIP?)¦¦true¦xref::graph-querying/node-querying.adoc
¦procedure¦apoc.nodes.link¦apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?, config = {} :: MAP?) :: VOID¦apoc.nodes.link([nodes],'REL_TYPE', conf) - creates a linked list of nodes from first to last¦true¦xref::graph-updates/data-creation.adoc
¦procedure¦apoc.nodes.rels¦apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)¦apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these ids¦true¦xref::graph-querying/node-querying.adoc
¦procedure¦apoc.path.expand¦apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)¦apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters¦true¦xref::graph-querying/expand-paths.adoc
¦procedure¦apoc.path.expandConfig¦apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)¦apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters. ¦true¦xref::graph-querying/expand-paths-config.adoc
¦procedure¦apoc.path.spanningTree¦apoc.path.spanningTree(start :: ANY?, config :: MAP?) :: (path :: PATH?)¦apoc.path.spanningTree(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters¦true¦xref::graph-querying/path-querying.adoc
¦procedure¦apoc.path.subgraphAll¦apoc.path.subgraphAll(start :: ANY?, config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.path.subgraphAll(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph¦true¦xref::graph-querying/expand-subgraph.adoc
¦procedure¦apoc.path.subgraphNodes¦apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)¦apoc.path.subgraphNodes(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters¦true¦xref::graph-querying/path-querying.adoc
¦procedure¦apoc.periodic.cancel¦apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)¦apoc.periodic.cancel(name) - cancel job with the given name¦true¦
¦procedure¦apoc.periodic.commit¦apoc.periodic.commit(statement :: STRING?, params = {} :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, failedBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?, wasTerminated :: BOOLEAN?)¦apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0¦true¦
¦procedure¦apoc.periodic.countdown¦apoc.periodic.countdown(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)¦apoc.periodic.countdown('name',statement,repeat-rate-in-seconds) submit a repeatedly-called background statement until it returns 0¦true¦
¦procedure¦apoc.periodic.iterate¦apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)¦apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows¦true¦
¦procedure¦apoc.periodic.list¦apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)¦apoc.periodic.list - list all jobs¦true¦
¦procedure¦apoc.periodic.repeat¦apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?, config = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)¦apoc.periodic.repeat('name',statement,repeat-rate-in-seconds, config) submit a repeatedly-called background statement. Fourth parameter 'config' is optional and can contain 'params' entry for nested statement.¦true¦
¦procedure¦apoc.periodic.rock_n_roll¦apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)¦apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows¦false¦xref::graph-updates/periodic-execution.adoc#periodic-rock-n-roll
¦procedure¦apoc.periodic.rock_n_roll_while¦apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)¦apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows¦false¦
¦procedure¦apoc.periodic.submit¦apoc.periodic.submit(name :: STRING?, statement :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)¦apoc.periodic.submit('name',statement) - submit a one-off background statement¦true¦
¦procedure¦apoc.periodic.truncate¦apoc.periodic.truncate(config = {} :: MAP?) :: VOID¦apoc.periodic.truncate(\{config}) - removes all entities (and optionally indexes and constraints) from db using the apoc.periodic.iterate under the hood¦true¦
¦procedure¦apoc.refactor.categorize¦apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID¦apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it¦true¦
¦procedure¦apoc.refactor.cloneNodes¦apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?, withRelationships = false :: BOOLEAN?, skipProperties = [] :: LIST? OF STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)¦apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties¦true¦
¦procedure¦apoc.refactor.cloneNodesWithRelationships¦apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)¦apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships¦true¦xref::graph-updates/graph-refactoring/clone-nodes.adoc
¦procedure¦apoc.refactor.cloneSubgraph¦apoc.refactor.cloneSubgraph(nodes :: LIST? OF NODE?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)¦apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.¦true¦
¦procedure¦apoc.refactor.cloneSubgraphFromPaths¦apoc.refactor.cloneSubgraphFromPaths(paths :: LIST? OF PATH?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)¦apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.¦true¦
¦procedure¦apoc.refactor.collapseNode¦apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)¦apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship¦true¦
¦procedure¦apoc.refactor.deleteAndReconnect¦apoc.refactor.deleteAndReconnect(path :: PATH?, nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦apoc.refactor.deleteAndReconnect([pathLinkedList], [nodesToRemove], \{config}) - Removes some nodes from a linked list¦true¦
¦procedure¦apoc.refactor.extractNode¦apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)¦apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships¦true¦
¦procedure¦apoc.refactor.from¦apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)¦apoc.refactor.from(rel, startNode) redirect relationship to use new start-node¦true¦xref::graph-updates/graph-refactoring/redirect-relationship.adoc
¦procedure¦apoc.refactor.invert¦apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)¦apoc.refactor.invert(rel) inverts relationship direction¦true¦xref::graph-updates/graph-refactoring/invert-relationship.adoc
¦procedure¦apoc.refactor.mergeNodes¦apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (node :: NODE?)¦apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list¦true¦xref::graph-updates/graph-refactoring/merge-nodes.adoc
¦procedure¦apoc.refactor.mergeRelationships¦apoc.refactor.mergeRelationships(rels :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (rel :: RELATIONSHIP?)¦apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list¦true¦xref::graph-updates/graph-refactoring/merge-nodes.adoc
¦procedure¦apoc.refactor.normalizeAsBoolean¦apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID¦apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean¦true¦
¦procedure¦apoc.refactor.rename.label¦apoc.refactor.rename.label(oldLabel :: STRING?, newLabel :: STRING?, nodes = [] :: LIST? OF NODE?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)¦apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) | rename a label from 'oldLabel' to 'newLabel' for all nodes. If 'nodes' is provided renaming is applied to this set only¦true¦xref::graph-updates/graph-refactoring/rename-label-type-property.adoc
¦procedure¦apoc.refactor.rename.nodeProperty¦apoc.refactor.rename.nodeProperty(oldName :: STRING?, newName :: STRING?, nodes = [] :: LIST? OF NODE?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)¦apoc.refactor.rename.nodeProperty(oldName, newName, [nodes], \{config}) | rename all node's property from 'oldName' to 'newName'. If 'nodes' is provided renaming is applied to this set only¦true¦xref::graph-updates/graph-refactoring/rename-label-type-property.adoc
¦procedure¦apoc.refactor.rename.type¦apoc.refactor.rename.type(oldType :: STRING?, newType :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)¦apoc.refactor.rename.type(oldType, newType, [rels], \{config}) | rename all relationships with type 'oldType' to 'newType'. If 'rels' is provided renaming is applied to this set only¦true¦xref::graph-updates/graph-refactoring/rename-label-type-property.adoc
¦procedure¦apoc.refactor.rename.typeProperty¦apoc.refactor.rename.typeProperty(oldName :: STRING?, newName :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)¦apoc.refactor.rename.typeProperty(oldName, newName, [rels], \{config}) | rename all relationship's property from 'oldName' to 'newName'. If 'rels' is provided renaming is applied to this set only¦true¦xref::graph-updates/graph-refactoring/rename-label-type-property.adoc
¦procedure¦apoc.refactor.setType¦apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)¦apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type¦true¦xref::graph-updates/graph-refactoring/set-relationship-type.adoc
¦procedure¦apoc.refactor.to¦apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)¦  apoc.refactor.to(rel, endNode) redirect relationship to use new end-node¦true¦xref::graph-updates/graph-refactoring/redirect-relationship.adoc
¦procedure¦apoc.schema.assert¦apoc.schema.assert(indexes :: MAP?, constraints :: MAP?, dropExisting = true :: BOOLEAN?) :: (label :: STRING?, key :: STRING?, keys :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)¦apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2...] pairings.¦true¦xref::indexes/schema-index-operations.adoc
¦procedure¦apoc.schema.nodes¦apoc.schema.nodes(config = {} :: MAP?) :: (name :: STRING?, label :: STRING?, properties :: LIST? OF STRING?, status :: STRING?, type :: STRING?, failure :: STRING?, populationProgress :: FLOAT?, size :: INTEGER?, valuesSelectivity :: FLOAT?, userDescription :: STRING?)¦CALL apoc.schema.nodes([config]) yield name, label, properties, status, type¦true¦xref::indexes/schema-index-operations.adoc
¦procedure¦apoc.schema.properties.distinct¦apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)¦apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key¦true¦xref::indexes/schema-index-operations.adoc
¦procedure¦apoc.schema.properties.distinctCount¦apoc.schema.properties.distinctCount(label =  :: STRING?, key =  :: STRING?) :: (label :: STRING?, key :: STRING?, value :: ANY?, count :: INTEGER?)¦apoc.schema.properties.distinctCount([label], [key]) YIELD label, key, value, count - quickly returns all distinct values and counts for a given key¦true¦xref::indexes/schema-index-operations.adoc
¦procedure¦apoc.schema.relationships¦apoc.schema.relationships(config = {} :: MAP?) :: (name :: STRING?, type :: STRING?, properties :: LIST? OF STRING?, status :: STRING?)¦CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status¦true¦xref::indexes/schema-index-operations.adoc
¦procedure¦apoc.search.multiSearchReduced¦apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)¦Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.¦true¦
¦procedure¦apoc.search.node¦apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)¦Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.¦true¦xref::graph-querying/parallel-node-search.adoc
¦procedure¦apoc.search.nodeAll¦apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)¦Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.¦true¦xref::graph-querying/parallel-node-search.adoc
¦procedure¦apoc.search.nodeAllReduced¦apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)¦Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH / = / <> / < / > ..., value ). All 'hits' are returned.¦true¦xref::graph-querying/parallel-node-search.adoc
¦procedure¦apoc.search.nodeReduced¦apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)¦Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.¦true¦xref::graph-querying/parallel-node-search.adoc
¦procedure¦apoc.spatial.geocode¦apoc.spatial.geocode(location :: STRING?, maxResults = 100 :: INTEGER?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)¦apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)¦true¦xref::misc/spatial.adoc
¦procedure¦apoc.spatial.geocodeOnce¦apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)¦apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)¦true¦xref::misc/spatial.adoc
¦procedure¦apoc.spatial.reverseGeocode¦apoc.spatial.reverseGeocode(latitude :: FLOAT?, longitude :: FLOAT?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)¦apoc.spatial.reverseGeocode(latitude,longitude) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)¦true¦xref::misc/spatial.adoc
¦procedure¦apoc.spatial.sortByDistance¦apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)¦apoc.spatial.sortByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order¦true¦xref::misc/spatial.adoc
¦procedure¦apoc.static.get¦apoc.static.get(key :: STRING?) :: (value :: ANY?)¦apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage¦false¦xref::misc/static-values.adoc
¦procedure¦apoc.static.list¦apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)¦apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage¦false¦xref::misc/static-values.adoc
¦procedure¦apoc.static.set¦apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)¦apoc.static.set(name, value) - stores value under key for server lifetime storage, returns previously stored or configured value¦false¦xref::misc/static-values.adoc
¦procedure¦apoc.stats.degrees¦apoc.stats.degrees(types =  :: STRING?) :: (type :: STRING?, direction :: STRING?, total :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?)¦¦true¦
¦procedure¦apoc.systemdb.execute¦apoc.systemdb.execute(DDL commands, either a string or a list of strings :: ANY?, params = {} :: MAP?) :: (row :: MAP?)¦¦false¦
¦procedure¦apoc.systemdb.graph¦apoc.systemdb.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)¦¦false¦
¦procedure¦apoc.text.doubleMetaphone¦apoc.text.doubleMetaphone(value :: ANY?) :: (value :: STRING?)¦apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings¦true¦
¦procedure¦apoc.text.phonetic¦apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)¦apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings¦true¦
¦procedure¦apoc.text.phoneticDelta¦apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)¦apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings¦true¦
¦procedure¦apoc.trigger.add¦apoc.trigger.add(name :: STRING?, kernelTransaction :: STRING?, selector :: MAP?, config = {} :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦add a trigger kernelTransaction under a name, in the kernelTransaction you can use \{createdNodes}, \{deletedNodes} etc., the selector is {phase:'before/after/rollback'} returns previous and new trigger information. Takes in an optional configuration.¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.trigger.list¦apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦list all installed triggers¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.trigger.pause¦apoc.trigger.pause(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦CALL apoc.trigger.pause(name) | it pauses the trigger¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.trigger.remove¦apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦remove previously added trigger, returns trigger information¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.trigger.removeAll¦apoc.trigger.removeAll() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦removes all previously added trigger, returns trigger information¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.trigger.resume¦apoc.trigger.resume(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)¦CALL apoc.trigger.resume(name) | it resumes the paused trigger¦true¦xref::background-operations/triggers.adoc
¦procedure¦apoc.ttl.expire¦apoc.ttl.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID¦CALL apoc.ttl.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property¦false¦xref::graph-updates/ttl.adoc
¦procedure¦apoc.ttl.expireIn¦apoc.ttl.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID¦CALL apoc.ttl.expireIn(node,timeDelta,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property¦false¦xref::graph-updates/ttl.adoc
¦procedure¦apoc.util.sleep¦apoc.util.sleep(duration :: INTEGER?) :: VOID¦apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored¦true¦
¦procedure¦apoc.util.validate¦apoc.util.validate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: VOID¦apoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception¦true¦
¦procedure¦apoc.uuid.install¦apoc.uuid.install(label :: STRING?, config = {} :: MAP?) :: (batchComputationResult :: MAP?, label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)¦CALL apoc.uuid.install(label, {addToExistingNodes: true/false, uuidProperty: 'uuid'}) yield label, installed, properties, batchComputationResult | it will add the uuid transaction handler
for the provided `label` and `uuidProperty`, in case the UUID handler is already present it will be replaced by the new one¦false¦xref::graph-updates/uuid.adoc
¦procedure¦apoc.uuid.list¦apoc.uuid.list() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)¦CALL apoc.uuid.list() yield label, installed, properties | provides a list of all the uuid handlers installed with the related configuration¦false¦xref::graph-updates/uuid.adoc
¦procedure¦apoc.uuid.remove¦apoc.uuid.remove(label :: STRING?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)¦CALL apoc.uuid.remove(label) yield label, installed, properties | remove previously added uuid handler and returns uuid information. All the existing uuid properties are left as-is¦false¦xref::graph-updates/uuid.adoc
¦procedure¦apoc.uuid.removeAll¦apoc.uuid.removeAll() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)¦CALL apoc.uuid.removeAll() yield label, installed, properties | it removes all previously added uuid handlers and returns uuids information. All the existing uuid properties are left as-is¦false¦xref::graph-updates/uuid.adoc
¦procedure¦apoc.warmup.run¦apoc.warmup.run(loadProperties = false :: BOOLEAN?, loadDynamicProperties = false :: BOOLEAN?, loadIndexes = false :: BOOLEAN?) :: (pageSize :: INTEGER?, totalTime :: INTEGER?, transactionWasTerminated :: BOOLEAN?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, relGroupsPerPage :: INTEGER?, relGroupsTotal :: INTEGER?, relGroupPages :: INTEGER?, relGroupsTime :: INTEGER?, propertiesLoaded :: BOOLEAN?, dynamicPropertiesLoaded :: BOOLEAN?, propsPerPage :: INTEGER?, propRecordsTotal :: INTEGER?, propPages :: INTEGER?, propsTime :: INTEGER?, stringPropsPerPage :: INTEGER?, stringPropRecordsTotal :: INTEGER?, stringPropPages :: INTEGER?, stringPropsTime :: INTEGER?, arrayPropsPerPage :: INTEGER?, arrayPropRecordsTotal :: INTEGER?, arrayPropPages :: INTEGER?, arrayPropsTime :: INTEGER?, indexesLoaded :: BOOLEAN?, indexPages :: INTEGER?, indexTime :: INTEGER?)¦apoc.warmup.run(loadProperties=false,loadDynamicProperties=false,loadIndexes=false) - quickly loads all nodes and rels into memory by skipping one page at a time¦true¦
¦procedure¦apoc.when¦apoc.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)¦apoc.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes read-only ifQuery or elseQuery with the given parameters¦true¦xref::cypher-execution/conditionals.adoc
¦procedure¦apoc.xml.import¦apoc.xml.import(url :: STRING?, config = {} :: MAP?) :: (node :: NODE?)¦Deprecated by apoc.import.xml¦true¦
¦function¦apoc.agg.first¦apoc.agg.first(value :: ANY?) :: (ANY?)¦apoc.agg.first(value) - returns first value¦true¦
¦function¦apoc.agg.graph¦apoc.agg.graph(element :: ANY?) :: (MAP?)¦apoc.agg.graph(path) - returns map of graph {nodes, relationships} of all distinct nodes and relationships¦true¦
¦function¦apoc.agg.last¦apoc.agg.last(value :: ANY?) :: (ANY?)¦apoc.agg.last(value) - returns last value¦true¦
¦function¦apoc.agg.maxItems¦apoc.agg.maxItems(item :: ANY?, value :: ANY?, groupLimit = -1 :: INTEGER?) :: (ANY?)¦apoc.agg.maxItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the maximum value present, and `items` are all items with the same value. The number of items can be optionally limited.¦true¦
¦function¦apoc.agg.median¦apoc.agg.median(value :: ANY?) :: (ANY?)¦apoc.agg.median(number) - returns median for non-null numeric values¦true¦
¦function¦apoc.agg.minItems¦apoc.agg.minItems(item :: ANY?, value :: ANY?, groupLimit = -1 :: INTEGER?) :: (ANY?)¦apoc.agg.minItems(item, value, groupLimit: -1) - returns a map {items:[], value:n} where `value` is the minimum value present, and `items` are all items with the same value. The number of items can be optionally limited.¦true¦
¦function¦apoc.agg.nth¦apoc.agg.nth(value :: ANY?, value :: INTEGER?) :: (ANY?)¦apoc.agg.nth(value,offset) - returns value of nth row (or -1 for last)¦true¦
¦function¦apoc.agg.percentiles¦apoc.agg.percentiles(value :: NUMBER?, percentiles = [0.5, 0.75, 0.9, 0.95, 0.99] :: LIST? OF FLOAT?) :: (LIST? OF ANY?)¦apoc.agg.percentiles(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns given percentiles for values¦true¦
¦function¦apoc.agg.product¦apoc.agg.product(number :: NUMBER?) :: (NUMBER?)¦apoc.agg.product(number) - returns given product for non-null values¦true¦
¦function¦apoc.agg.slice¦apoc.agg.slice(value :: ANY?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.agg.slice(value, start, length) - returns subset of non-null values, start is 0 based and length can be -1¦true¦
¦function¦apoc.agg.statistics¦apoc.agg.statistics(value :: NUMBER?, percentiles = [0.5, 0.75, 0.9, 0.95, 0.99] :: LIST? OF FLOAT?) :: (MAP?)¦apoc.agg.statistics(value,[percentiles = 0.5,0.75,0.9,0.95,0.99]) - returns numeric statistics (percentiles, min,minNonZero,max,total,mean,stdev) for values¦true¦
¦function¦apoc.any.properties¦apoc.any.properties(thing :: ANY?, keys = null :: LIST? OF STRING?) :: (MAP?)¦returns properties for virtual and real, nodes, rels and maps¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.any.property¦apoc.any.property(thing :: ANY?, key :: STRING?) :: (ANY?)¦returns property for virtual and real, nodes, rels and maps¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.bitwise.op¦apoc.bitwise.op(a :: INTEGER?, operator :: STRING?, b :: INTEGER?) :: (INTEGER?)¦apoc.bitwise.op(60,'|',13) bitwise operations a & b, a | b, a ^ b, ~a, a >> b, a >>> b, a << b. returns the result of the bitwise operation¦true¦
¦function¦apoc.coll.avg¦apoc.coll.avg(numbers :: LIST? OF NUMBER?) :: (FLOAT?)¦apoc.coll.avg([0.5,1,2.3])¦true¦
¦function¦apoc.coll.combinations¦apoc.coll.combinations(coll :: LIST? OF ANY?, minSelect :: INTEGER?, maxSelect = -1 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.combinations(coll, minSelect, maxSelect:minSelect) - Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive¦true¦
¦function¦apoc.coll.contains¦apoc.coll.contains(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)¦apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)¦true¦
¦function¦apoc.coll.containsAll¦apoc.coll.containsAll(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)¦true¦
¦function¦apoc.coll.containsAllSorted¦apoc.coll.containsAllSorted(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)¦true¦
¦function¦apoc.coll.containsDuplicates¦apoc.coll.containsDuplicates(coll :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements¦true¦
¦function¦apoc.coll.containsSorted¦apoc.coll.containsSorted(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)¦apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)¦true¦
¦function¦apoc.coll.different¦apoc.coll.different(values :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.coll.different(values) - returns true if values are different¦true¦
¦function¦apoc.coll.disjunction¦apoc.coll.disjunction(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists¦true¦
¦function¦apoc.coll.dropDuplicateNeighbors¦apoc.coll.dropDuplicateNeighbors(list :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.dropDuplicateNeighbors(list) - remove duplicate consecutive objects in a list¦true¦
¦function¦apoc.coll.duplicates¦apoc.coll.duplicates(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection¦true¦
¦function¦apoc.coll.duplicatesWithCount¦apoc.coll.duplicatesWithCount(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)¦true¦
¦function¦apoc.coll.fill¦apoc.coll.fill(item :: STRING?, count :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.fill(item, count) - returns a list with the given count of items¦true¦
¦function¦apoc.coll.flatten¦apoc.coll.flatten(coll :: LIST? OF ANY?, recursive = false :: BOOLEAN?) :: (LIST? OF ANY?)¦apoc.coll.flatten(coll, [recursive]) - flattens list (nested if recursive is true)¦true¦
¦function¦apoc.coll.frequencies¦apoc.coll.frequencies(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.frequencies(coll) - returns a list of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]`)¦true¦
¦function¦apoc.coll.frequenciesAsMap¦apoc.coll.frequenciesAsMap(coll :: LIST? OF ANY?) :: (MAP?)¦apoc.coll.frequenciesAsMap(coll) - return a map of frequencies of the items in the collection, key `item`, value `count` (e.g., `{1:2, 2:1}`)¦true¦
¦function¦apoc.coll.indexOf¦apoc.coll.indexOf(coll :: LIST? OF ANY?, value :: ANY?) :: (INTEGER?)¦apoc.coll.indexOf(coll, value) | position of value in the list¦true¦
¦function¦apoc.coll.insert¦apoc.coll.insert(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)¦apoc.coll.insert(coll, index, value) | insert value at index¦true¦
¦function¦apoc.coll.insertAll¦apoc.coll.insertAll(coll :: LIST? OF ANY?, index :: INTEGER?, values :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.insertAll(coll, index, values) | insert values at index¦true¦
¦function¦apoc.coll.intersection¦apoc.coll.intersection(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.intersection(first, second) - returns the unique intersection of the two lists¦true¦
¦function¦apoc.coll.isEqualCollection¦apoc.coll.isEqualCollection(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.coll.isEqualCollection(coll, values) return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)¦true¦
¦function¦apoc.coll.max¦apoc.coll.max(values :: LIST? OF ANY?) :: (ANY?)¦apoc.coll.max([0.5,1,2.3])¦true¦
¦function¦apoc.coll.min¦apoc.coll.min(values :: LIST? OF ANY?) :: (ANY?)¦apoc.coll.min([0.5,1,2.3])¦true¦
¦function¦apoc.coll.occurrences¦apoc.coll.occurrences(coll :: LIST? OF ANY?, item :: ANY?) :: (INTEGER?)¦apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection¦true¦
¦function¦apoc.coll.pairWithOffset¦apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset¦true¦
¦function¦apoc.coll.pairs¦apoc.coll.pairs(list :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] ¦true¦
¦function¦apoc.coll.pairsMin¦apoc.coll.pairsMin(list :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]¦true¦
¦function¦apoc.coll.partition¦apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.partition(list,batchSize)¦true¦
¦function¦apoc.coll.randomItem¦apoc.coll.randomItem(coll :: LIST? OF ANY?) :: (ANY?)¦apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list¦true¦
¦function¦apoc.coll.randomItems¦apoc.coll.randomItems(coll :: LIST? OF ANY?, itemCount :: INTEGER?, allowRepick = false :: BOOLEAN?) :: (LIST? OF ANY?)¦apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again¦true¦
¦function¦apoc.coll.remove¦apoc.coll.remove(coll :: LIST? OF ANY?, index :: INTEGER?, length = 1 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.remove(coll, index, [length=1]) | remove range of values from index to length¦true¦
¦function¦apoc.coll.removeAll¦apoc.coll.removeAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed¦true¦
¦function¦apoc.coll.reverse¦apoc.coll.reverse(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.reverse(coll) - returns reversed list¦true¦
¦function¦apoc.coll.runningTotal¦apoc.coll.runningTotal(list :: LIST? OF NUMBER?) :: (LIST? OF ANY?)¦apoc.coll.runningTotal(list1) - returns an accumulative array. For example apoc.coll.runningTotal([1,2,3.5]) return [1,3,6.5]¦true¦
¦function¦apoc.coll.set¦apoc.coll.set(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)¦apoc.coll.set(coll, index, value) | set index to value¦true¦
¦function¦apoc.coll.shuffle¦apoc.coll.shuffle(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.shuffle(coll) - returns the shuffled list¦true¦
¦function¦apoc.coll.sort¦apoc.coll.sort(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.sort(coll) sort on Collections¦true¦
¦function¦apoc.coll.sortMaps¦apoc.coll.sortMaps(coll :: LIST? OF MAP?, prop :: STRING?) :: (LIST? OF ANY?)¦apoc.coll.sortMaps([maps], 'name') - sort maps by property¦true¦
¦function¦apoc.coll.sortMulti¦apoc.coll.sortMulti(coll :: LIST? OF MAP?, orderFields = [] :: LIST? OF STRING?, limit = -1 :: INTEGER?, skip = 0 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.coll.sortMulti(coll, ['^name','age'],[limit],[skip]) - sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip¦true¦
¦function¦apoc.coll.sortNodes¦apoc.coll.sortNodes(coll :: LIST? OF NODE?, prop :: STRING?) :: (LIST? OF ANY?)¦apoc.coll.sortNodes([nodes], 'name') sort nodes by property¦true¦
¦function¦apoc.coll.sortText¦apoc.coll.sortText(coll :: LIST? OF STRING?, conf = {} :: MAP?) :: (LIST? OF ANY?)¦apoc.coll.sortText(coll) sort on string based collections¦true¦
¦function¦apoc.coll.stdev¦apoc.coll.stdev(list :: LIST? OF NUMBER?, isBiasCorrected = true :: BOOLEAN?) :: (NUMBER?)¦apoc.coll.stdev(list, isBiasCorrected) - returns the sample or population standard deviation with isBiasCorrected true or false respectively. For example apoc.coll.stdev([10, 12, 23]) return 7¦true¦
¦function¦apoc.coll.subtract¦apoc.coll.subtract(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed¦true¦
¦function¦apoc.coll.sum¦apoc.coll.sum(numbers :: LIST? OF NUMBER?) :: (FLOAT?)¦apoc.coll.sum([0.5,1,2.3])¦true¦
¦function¦apoc.coll.sumLongs¦apoc.coll.sumLongs(numbers :: LIST? OF NUMBER?) :: (INTEGER?)¦apoc.coll.sumLongs([1,3,3])¦true¦
¦function¦apoc.coll.toSet¦apoc.coll.toSet(values :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.toSet([list]) returns a unique list backed by a set¦true¦
¦function¦apoc.coll.union¦apoc.coll.union(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.union(first, second) - creates the distinct union of the 2 lists¦true¦
¦function¦apoc.coll.unionAll¦apoc.coll.unionAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists¦true¦
¦function¦apoc.coll.zip¦apoc.coll.zip(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (LIST? OF ANY?)¦apoc.coll.zip([list1],[list2])¦true¦
¦function¦apoc.convert.fromJsonList¦apoc.convert.fromJsonList(list :: STRING?, path =  :: STRING?) :: (LIST? OF ANY?)¦apoc.convert.fromJsonList('[1,2,3]'[,'json-path'])¦true¦
¦function¦apoc.convert.fromJsonMap¦apoc.convert.fromJsonMap(map :: STRING?, path =  :: STRING?) :: (MAP?)¦apoc.convert.fromJsonMap('{"a":42,"b":"foo","c":[1,2,3]}'[,'json-path'])¦true¦
¦function¦apoc.convert.getJsonProperty¦apoc.convert.getJsonProperty(node :: NODE?, key :: STRING?, path =  :: STRING?) :: (ANY?)¦apoc.convert.getJsonProperty(node,key[,'json-path']) - converts serialized JSON in property back to original object¦true¦
¦function¦apoc.convert.getJsonPropertyMap¦apoc.convert.getJsonPropertyMap(node :: NODE?, key :: STRING?, path =  :: STRING?) :: (MAP?)¦apoc.convert.getJsonPropertyMap(node,key[,'json-path']) - converts serialized JSON in property back to map¦true¦
¦function¦apoc.convert.toBoolean¦apoc.convert.toBoolean(bool :: ANY?) :: (BOOLEAN?)¦apoc.convert.toBoolean(value) | tries it's best to convert the value to a boolean¦true¦
¦function¦apoc.convert.toBooleanList¦apoc.convert.toBooleanList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toBooleanList(value) | tries it's best to convert the value to a list of booleans¦true¦
¦function¦apoc.convert.toFloat¦apoc.convert.toFloat(object :: ANY?) :: (FLOAT?)¦apoc.convert.toFloat(value) | tries it's best to convert the value to a float¦true¦
¦function¦apoc.convert.toIntList¦apoc.convert.toIntList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toIntList(value) | tries it's best to convert the value to a list of integers¦true¦
¦function¦apoc.convert.toInteger¦apoc.convert.toInteger(object :: ANY?) :: (INTEGER?)¦apoc.convert.toInteger(value) | tries it's best to convert the value to an integer¦true¦
¦function¦apoc.convert.toJson¦apoc.convert.toJson(value :: ANY?) :: (STRING?)¦apoc.convert.toJson([1,2,3]) or toJson({a:42,b:"foo",c:[1,2,3]}) or toJson(NODE/REL/PATH)¦true¦
¦function¦apoc.convert.toList¦apoc.convert.toList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toList(value) | tries it's best to convert the value to a list¦true¦
¦function¦apoc.convert.toMap¦apoc.convert.toMap(map :: ANY?) :: (MAP?)¦apoc.convert.toMap(value) | tries it's best to convert the value to a map¦true¦
¦function¦apoc.convert.toNode¦apoc.convert.toNode(node :: ANY?) :: (NODE?)¦apoc.convert.toNode(value) | tries it's best to convert the value to a node¦true¦
¦function¦apoc.convert.toNodeList¦apoc.convert.toNodeList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toNodeList(value) | tries it's best to convert the value to a list of nodes¦true¦
¦function¦apoc.convert.toRelationship¦apoc.convert.toRelationship(relationship :: ANY?) :: (RELATIONSHIP?)¦apoc.convert.toRelationship(value) | tries it's best to convert the value to a relationship¦true¦
¦function¦apoc.convert.toRelationshipList¦apoc.convert.toRelationshipList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toRelationshipList(value) | tries it's best to convert the value to a list of relationships¦true¦
¦function¦apoc.convert.toSet¦apoc.convert.toSet(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toSet(value) | tries it's best to convert the value to a set¦true¦
¦function¦apoc.convert.toSortedJsonMap¦apoc.convert.toSortedJsonMap(value :: ANY?, ignoreCase = true :: BOOLEAN?) :: (STRING?)¦apoc.convert.toSortedJsonMap(node|map, ignoreCase:true) - returns a JSON map with keys sorted alphabetically, with optional case sensitivity¦true¦
¦function¦apoc.convert.toString¦apoc.convert.toString(string :: ANY?) :: (STRING?)¦apoc.convert.toString(value) | tries it's best to convert the value to a string¦true¦
¦function¦apoc.convert.toStringList¦apoc.convert.toStringList(list :: ANY?) :: (LIST? OF ANY?)¦apoc.convert.toStringList(value) | tries it's best to convert the value to a list of strings¦true¦
¦function¦apoc.create.uuid¦apoc.create.uuid() :: (STRING?)¦apoc.create.uuid() - creates an UUID¦true¦xref::graph-updates/uuid.adoc
¦function¦apoc.create.vNode¦apoc.create.vNode(label :: LIST? OF STRING?, props = {} :: MAP?) :: (NODE?)¦apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node¦true¦xref::virtual/virtual-nodes-rels.adoc
¦function¦apoc.create.vRelationship¦apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (RELATIONSHIP?)¦apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship¦true¦xref::virtual/virtual-nodes-rels.adoc
¦function¦apoc.create.virtual.fromNode¦apoc.create.virtual.fromNode(node :: NODE?, propertyNames :: LIST? OF STRING?) :: (NODE?)¦apoc.create.virtual.fromNode(node, [propertyNames]) returns a virtual node built from an existing node with only the requested properties¦true¦xref::virtual/virtual-nodes-rels.adoc
¦function¦apoc.cypher.runFirstColumn¦apoc.cypher.runFirstColumn(cypher :: STRING?, params :: MAP?, expectMultipleValues = true :: BOOLEAN?) :: (ANY?)¦use either apoc.cypher.runFirstColumnMany for a list return or apoc.cypher.runFirstColumnSingle for returning the first row of the first column¦true¦xref::cypher-execution/index.adoc
¦function¦apoc.cypher.runFirstColumnMany¦apoc.cypher.runFirstColumnMany(cypher :: STRING?, params :: MAP?) :: (LIST? OF ANY?)¦apoc.cypher.runFirstColumnMany(statement, params) - executes statement with given parameters, returns first column only collected into a list, params are available as identifiers¦true¦xref::cypher-execution/index.adoc
¦function¦apoc.cypher.runFirstColumnSingle¦apoc.cypher.runFirstColumnSingle(cypher :: STRING?, params :: MAP?) :: (ANY?)¦apoc.cypher.runFirstColumnSingle(statement, params) - executes statement with given parameters, returns first element of the first column only, params are available as identifiers¦true¦xref::cypher-execution/index.adoc
¦function¦apoc.data.domain¦apoc.data.domain(url_or_email_address :: STRING?) :: (STRING?)¦apoc.data.domain('url_or_email_address') YIELD domain - extract the domain name from a url or an email address. If nothing was found, yield null.¦true¦
¦function¦apoc.data.email¦apoc.data.email(email_address :: STRING?) :: (MAP?)¦apoc.data.email('email_address') as {personal,user,domain} - extract the personal name, user and domain as a map¦true¦
¦function¦apoc.data.url¦apoc.data.url(url :: STRING?) :: (MAP?)¦apoc.data.url('url') as {protocol,host,port,path,query,file,anchor,user} | turn URL into map structure¦true¦
¦function¦apoc.date.add¦apoc.date.add(time :: INTEGER?, unit :: STRING?, addValue :: INTEGER?, addUnit :: STRING?) :: (INTEGER?)¦apoc.date.add(12345, 'ms', -365, 'd') - given a timestamp in one time unit, adds a value of the specified time unit¦true¦
¦function¦apoc.date.convert¦apoc.date.convert(time :: INTEGER?, unit :: STRING?, toUnit :: STRING?) :: (INTEGER?)¦apoc.date.convert(12345, 'ms', 'd') - convert a timestamp in one time unit into one of a different time unit¦true¦
¦function¦apoc.date.convertFormat¦apoc.date.convertFormat(temporal :: STRING?, currentFormat :: STRING?, convertTo = yyyy-MM-dd :: STRING?) :: (STRING?)¦apoc.date.convertFormat('Tue, 14 May 2019 14:52:06 -0400', 'rfc_1123_date_time', 'iso_date_time') - convert a String of one date format into a String of another date format.¦true¦
¦function¦apoc.date.currentTimestamp¦apoc.date.currentTimestamp() :: (INTEGER?)¦apoc.date.currentTimestamp() - returns System.currentTimeMillis() at the time it was called. The value is current throughout transaction execution, and is different from Cypher’s timestamp() function, which does not update within a transaction.¦true¦
¦function¦apoc.date.field¦apoc.date.field(time :: INTEGER?, unit = d :: STRING?, timezone = UTC :: STRING?) :: (INTEGER?)¦apoc.date.field(12345,('ms|s|m|h|d|month|year'),('TZ')¦true¦
¦function¦apoc.date.fields¦apoc.date.fields(date :: STRING?, pattern = yyyy-MM-dd HH:mm:ss :: STRING?) :: (MAP?)¦apoc.date.fields('2012-12-23',('yyyy-MM-dd')) - return columns and a map representation of date parsed with the given format with entries for years,months,weekdays,days,hours,minutes,seconds,zoneid¦true¦
¦function¦apoc.date.format¦apoc.date.format(time :: INTEGER?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (STRING?)¦apoc.date.format(12345,('ms|s|m|h|d'),('yyyy-MM-dd HH:mm:ss zzz'),('TZ')) - get string representation of time value optionally using the specified unit (default ms) using specified format (default ISO) and specified time zone (default current TZ)¦true¦
¦function¦apoc.date.fromISO8601¦apoc.date.fromISO8601(time :: STRING?) :: (INTEGER?)¦apoc.date.fromISO8601('yyyy-MM-ddTHH:mm:ss.SSSZ') - return number representation of time in EPOCH format¦true¦
¦function¦apoc.date.parse¦apoc.date.parse(time :: STRING?, unit = ms :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone =  :: STRING?) :: (INTEGER?)¦apoc.date.parse('2012-12-23','ms|s|m|h|d','yyyy-MM-dd') - parse date string using the specified format into the specified time unit¦true¦
¦function¦apoc.date.parseAsZonedDateTime¦apoc.date.parseAsZonedDateTime(time :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone = UTC :: STRING?) :: (DATETIME?)¦apoc.date.parseAsZonedDateTime('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') - parse date string using the specified format to specified timezone¦true¦
¦function¦apoc.date.systemTimezone¦apoc.date.systemTimezone() :: (STRING?)¦apoc.date.systemTimezone() - returns the system timezone display name¦true¦
¦function¦apoc.date.toISO8601¦apoc.date.toISO8601(time :: INTEGER?, unit = ms :: STRING?) :: (STRING?)¦apoc.date.toISO8601(12345,('ms|s|m|h|d') - return string representation of time in ISO8601 format¦true¦
¦function¦apoc.date.toYears¦apoc.date.toYears(value :: ANY?, format = yyyy-MM-dd HH:mm:ss :: STRING?) :: (FLOAT?)¦toYears(timestamp) or toYears(date[,format]) - converts timestamp into floating point years¦true¦
¦function¦apoc.diff.nodes¦apoc.diff.nodes(leftNode :: NODE?, rightNode :: NODE?) :: (MAP?)¦¦true¦
¦function¦apoc.hashing.fingerprint¦apoc.hashing.fingerprint(some object :: ANY?, propertyExcludes = [] :: LIST? OF STRING?) :: (STRING?)¦calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.¦true¦xref::comparing-graphs/fingerprinting.adoc
¦function¦apoc.hashing.fingerprintGraph¦apoc.hashing.fingerprintGraph(propertyExcludes = [] :: LIST? OF STRING?) :: (STRING?)¦calculate a checksum (md5) over a the full graph. Be aware that this function does use in-memomry datastructures depending on the size of your graph.¦true¦xref::comparing-graphs/fingerprinting.adoc
¦function¦apoc.hashing.fingerprinting¦apoc.hashing.fingerprinting(some object :: ANY?, conf = {} :: MAP?) :: (STRING?)¦calculate a checksum (md5) over a node or a relationship. This deals gracefully with array properties. Two identical entities do share the same hash.¦true¦xref::comparing-graphs/fingerprinting.adoc
¦function¦apoc.json.path¦apoc.json.path(json :: STRING?, path = $ :: STRING?) :: (ANY?)¦apoc.json.path('\{json}','json-path')¦true¦
¦function¦apoc.label.exists¦apoc.label.exists(node :: ANY?, label :: STRING?) :: (BOOLEAN?)¦apoc.label.exists(element, label) - returns true or false related to label existance¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.map.clean¦apoc.map.clean(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)¦apoc.map.clean(map,[skip,keys],[skip,values]) yield map filters the keys and values contained in those lists, good for data cleaning from CSV/JSON¦true¦
¦function¦apoc.map.flatten¦apoc.map.flatten(map :: MAP?, delimiter = . :: STRING?) :: (MAP?)¦apoc.map.flatten(map, delimiter:'.') yield map - flattens nested items in map using dot notation¦true¦
¦function¦apoc.map.fromLists¦apoc.map.fromLists(keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)¦apoc.map.fromLists([keys],[values])¦true¦
¦function¦apoc.map.fromNodes¦apoc.map.fromNodes(label :: STRING?, property :: STRING?) :: (MAP?)¦apoc.map.fromNodes(label, property)¦true¦
¦function¦apoc.map.fromPairs¦apoc.map.fromPairs(pairs :: LIST? OF LIST? OF ANY?) :: (MAP?)¦apoc.map.fromPairs([[key,value],[key2,value2],...])¦true¦
¦function¦apoc.map.fromValues¦apoc.map.fromValues(values :: LIST? OF ANY?) :: (MAP?)¦apoc.map.fromValues([key1,value1,key2,value2,...])¦true¦
¦function¦apoc.map.get¦apoc.map.get(map :: MAP?, key :: STRING?, value = null :: ANY?, fail = true :: BOOLEAN?) :: (ANY?)¦apoc.map.get(map,key,[default],[fail=true]) - returns value for key or throws exception if key doesn't exist and no default given¦true¦
¦function¦apoc.map.groupBy¦apoc.map.groupBy(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)¦apoc.map.groupBy([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with single values¦true¦
¦function¦apoc.map.groupByMulti¦apoc.map.groupByMulti(values :: LIST? OF ANY?, key :: STRING?) :: (MAP?)¦apoc.map.groupByMulti([maps/nodes/relationships],'key') yield value - creates a map of the list keyed by the given property, with list values¦true¦
¦function¦apoc.map.merge¦apoc.map.merge(first :: MAP?, second :: MAP?) :: (MAP?)¦apoc.map.merge(first,second) - merges two maps¦true¦
¦function¦apoc.map.mergeList¦apoc.map.mergeList(maps :: LIST? OF MAP?) :: (MAP?)¦apoc.map.mergeList([\{maps}]) yield value - merges all maps in the list into one¦true¦
¦function¦apoc.map.mget¦apoc.map.mget(map :: MAP?, keys :: LIST? OF STRING?, values = [] :: LIST? OF ANY?, fail = true :: BOOLEAN?) :: (LIST? OF ANY?)¦apoc.map.mget(map,key,[defaults],[fail=true])  - returns list of values for keys or throws exception if one of the key doesn't exist and no default value given at that position¦true¦
¦function¦apoc.map.removeKey¦apoc.map.removeKey(map :: MAP?, key :: STRING?, config = {} :: MAP?) :: (MAP?)¦apoc.map.removeKey(map,key,{recursive:true/false}) - remove the key from the map (recursively if recursive is true)¦true¦
¦function¦apoc.map.removeKeys¦apoc.map.removeKeys(map :: MAP?, keys :: LIST? OF STRING?, config = {} :: MAP?) :: (MAP?)¦apoc.map.removeKeys(map,[keys],{recursive:true/false}) - remove the keys from the map (recursively if recursive is true)¦true¦
¦function¦apoc.map.setEntry¦apoc.map.setEntry(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)¦apoc.map.setEntry(map,key,value)¦true¦
¦function¦apoc.map.setKey¦apoc.map.setKey(map :: MAP?, key :: STRING?, value :: ANY?) :: (MAP?)¦apoc.map.setKey(map,key,value)¦true¦
¦function¦apoc.map.setLists¦apoc.map.setLists(map :: MAP?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (MAP?)¦apoc.map.setLists(map,[keys],[values])¦true¦
¦function¦apoc.map.setPairs¦apoc.map.setPairs(map :: MAP?, pairs :: LIST? OF LIST? OF ANY?) :: (MAP?)¦apoc.map.setPairs(map,[[key1,value1],[key2,value2])¦true¦
¦function¦apoc.map.setValues¦apoc.map.setValues(map :: MAP?, pairs :: LIST? OF ANY?) :: (MAP?)¦apoc.map.setValues(map,[key1,value1,key2,value2])¦true¦
¦function¦apoc.map.sortedProperties¦apoc.map.sortedProperties(map :: MAP?, ignoreCase = true :: BOOLEAN?) :: (LIST? OF ANY?)¦apoc.map.sortedProperties(map, ignoreCase:true) - returns a list of key/value list pairs, with pairs sorted by keys alphabetically, with optional case sensitivity¦true¦
¦function¦apoc.map.submap¦apoc.map.submap(map :: MAP?, keys :: LIST? OF STRING?, values = [] :: LIST? OF ANY?, fail = true :: BOOLEAN?) :: (MAP?)¦apoc.map.submap(map,keys,[defaults],[fail=true])  - returns submap for keys or throws exception if one of the key doesn't exist and no default value given at that position¦true¦
¦function¦apoc.map.unflatten¦apoc.map.unflatten(map :: MAP?, delimiter = . :: STRING?) :: (MAP?)¦apoc.map.unflatten(map, delimiter:'.') yield map - unflat from items separated by delimiter string to nested items (reverse of apoc.map.flatten function)¦true¦
¦function¦apoc.map.updateTree¦apoc.map.updateTree(tree :: MAP?, key :: STRING?, data :: LIST? OF LIST? OF ANY?) :: (MAP?)¦apoc.map.updateTree(tree,key,[[value,\{data}]]) returns map - adds the \{data} map on each level of the nested tree, where the key-value pairs match¦true¦
¦function¦apoc.map.values¦apoc.map.values(map :: MAP?, keys = [] :: LIST? OF STRING?, addNullsForMissing = false :: BOOLEAN?) :: (LIST? OF ANY?)¦apoc.map.values(map, [key1,key2,key3,...],[addNullsForMissing]) returns list of values indicated by the keys¦true¦
¦function¦apoc.math.maxByte¦apoc.math.maxByte() :: (INTEGER?)¦apoc.math.maxByte() | return the maximum value an byte can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.maxDouble¦apoc.math.maxDouble() :: (FLOAT?)¦apoc.math.maxDouble() | return the largest positive finite value of type double¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.maxInt¦apoc.math.maxInt() :: (INTEGER?)¦apoc.math.maxInt() | return the maximum value an int can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.maxLong¦apoc.math.maxLong() :: (INTEGER?)¦apoc.math.maxLong() | return the maximum value a long can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.minByte¦apoc.math.minByte() :: (INTEGER?)¦apoc.math.minByte() | return the minimum value an byte can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.minDouble¦apoc.math.minDouble() :: (FLOAT?)¦apoc.math.minDouble() | return the smallest positive nonzero value of type double¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.minInt¦apoc.math.minInt() :: (INTEGER?)¦apoc.math.minInt() | return the minimum value an int can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.minLong¦apoc.math.minLong() :: (INTEGER?)¦apoc.math.minLong() | return the minimum value a long can have¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.math.round¦apoc.math.round(value :: FLOAT?, precision = 0 :: INTEGER?, mode = HALF_UP :: STRING?) :: (FLOAT?)¦apoc.math.round(value,[precision],mode=['CEILING','FLOOR','UP','DOWN','HALF_EVEN','HALF_DOWN','HALF_UP','DOWN','UNNECESSARY'])¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.meta.cypher.isType¦apoc.meta.cypher.isType(value :: ANY?, type :: STRING?) :: (BOOLEAN?)¦apoc.meta.cypher.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF <TYPE>,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)¦true¦
¦function¦apoc.meta.cypher.type¦apoc.meta.cypher.type(value :: ANY?) :: (STRING?)¦apoc.meta.cypher.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,MAP,LIST OF <TYPE>,POINT,DATE,DATE_TIME,LOCAL_TIME,LOCAL_DATE_TIME,TIME,DURATION)¦true¦
¦function¦apoc.meta.cypher.types¦apoc.meta.cypher.types(properties :: ANY?) :: (MAP?)¦apoc.meta.cypher.types(node-relationship-map)  - returns a map of keys to types¦true¦
¦function¦apoc.meta.isType¦apoc.meta.isType(value :: ANY?, type :: STRING?) :: (BOOLEAN?)¦apoc.meta.isType(value,type) - returns a row if type name matches none if not (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)¦true¦
¦function¦apoc.meta.type¦apoc.meta.type(value :: ANY?) :: (STRING?)¦apoc.meta.type(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)¦true¦
¦function¦apoc.meta.typeName¦apoc.meta.typeName(value :: ANY?) :: (STRING?)¦apoc.meta.typeName(value) - type name of a value (INTEGER,FLOAT,STRING,BOOLEAN,RELATIONSHIP,NODE,PATH,NULL,UNKNOWN,MAP,LIST)¦true¦
¦function¦apoc.meta.types¦apoc.meta.types(properties :: ANY?) :: (MAP?)¦apoc.meta.types(node-relationship-map)  - returns a map of keys to types¦true¦
¦function¦apoc.node.degree¦apoc.node.degree(node :: NODE?, types =  :: STRING?) :: (INTEGER?)¦apoc.node.degree(node, rel-direction-pattern) - returns total degrees of the given relationships in the pattern, can use '>' or '<' for all outgoing or incoming relationships¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.degree.in¦apoc.node.degree.in(node :: NODE?, types =  :: STRING?) :: (INTEGER?)¦apoc.node.degree.in(node, relationshipName) - returns total number number of incoming relationships¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.degree.out¦apoc.node.degree.out(node :: NODE?, types =  :: STRING?) :: (INTEGER?)¦apoc.node.degree.out(node, relationshipName) - returns total number number of outgoing relationships¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.id¦apoc.node.id(node :: NODE?) :: (INTEGER?)¦returns id for (virtual) nodes¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.labels¦apoc.node.labels(node :: NODE?) :: (LIST? OF ANY?)¦returns labels for (virtual) nodes¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.relationship.exists¦apoc.node.relationship.exists(node :: NODE?, types =  :: STRING?) :: (BOOLEAN?)¦apoc.node.relationship.exists(node, rel-direction-pattern) - returns true when the node has the relationships of the pattern¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.relationship.types¦apoc.node.relationship.types(node :: NODE?, types =  :: STRING?) :: (LIST? OF ANY?)¦apoc.node.relationship.types(node, rel-direction-pattern) - returns a list of distinct relationship types¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.node.relationships.exist¦apoc.node.relationships.exist(node :: NODE?, types =  :: STRING?) :: (MAP?)¦apoc.node.relationships.exist(node, rel-direction-pattern) - returns a map with rel-pattern, boolean for the given relationship patterns¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.nodes.connected¦apoc.nodes.connected(start :: NODE?, start :: NODE?, types =  :: STRING?) :: (BOOLEAN?)¦apoc.nodes.connected(start, end, rel-direction-pattern) - returns true when the node is connected to the other node, optimized for dense nodes¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.nodes.isDense¦apoc.nodes.isDense(node :: NODE?) :: (BOOLEAN?)¦apoc.nodes.isDense(node) - returns true if it is a dense node¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.nodes.relationship.types¦apoc.nodes.relationship.types(ids :: ANY?, types =  :: STRING?) :: (LIST? OF ANY?)¦apoc.nodes.relationship.types(node|nodes|id|[ids], rel-direction-pattern) - returns a list of maps where each one has two fields: `node` which is the node subject of the analysis and `types` which is a list of distinct relationship types¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.nodes.relationships.exist¦apoc.nodes.relationships.exist(ids :: ANY?, types =  :: STRING?) :: (LIST? OF ANY?)¦apoc.nodes.relationships.exist(node|nodes|id|[ids], rel-direction-pattern) - returns a list of maps where each one has two fields: `node` which is the node subject of the analysis and `exists` which is a map with rel-pattern, boolean for the given relationship patterns¦true¦xref::graph-querying/node-querying.adoc
¦function¦apoc.number.arabicToRoman¦apoc.number.arabicToRoman(number :: ANY?) :: (STRING?)¦apoc.number.arabicToRoman(number)  | convert arabic numbers to roman¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.number.exact.add¦apoc.number.exact.add(stringA :: STRING?, stringB :: STRING?) :: (STRING?)¦apoc.number.exact.add(stringA,stringB) - return the sum's result of two large numbers¦true¦
¦function¦apoc.number.exact.div¦apoc.number.exact.div(stringA :: STRING?, stringB :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (STRING?)¦apoc.number.exact.div(stringA,stringB,[prec],[roundingModel]) - return the division's result of two large numbers¦true¦
¦function¦apoc.number.exact.mul¦apoc.number.exact.mul(stringA :: STRING?, stringB :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (STRING?)¦apoc.number.exact.mul(stringA,stringB,[prec],[roundingModel]) - return the multiplication's result of two large numbers ¦true¦
¦function¦apoc.number.exact.sub¦apoc.number.exact.sub(stringA :: STRING?, stringB :: STRING?) :: (STRING?)¦apoc.number.exact.sub(stringA,stringB) - return the substraction's of two large numbers¦true¦
¦function¦apoc.number.exact.toExact¦apoc.number.exact.toExact(number :: INTEGER?) :: (INTEGER?)¦apoc.number.exact.toExact(number) - return the exact value¦true¦
¦function¦apoc.number.exact.toFloat¦apoc.number.exact.toFloat(stringA :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (FLOAT?)¦apoc.number.exact.toFloat(string,[prec],[roundingMode]) - return the Float value of a large number¦true¦
¦function¦apoc.number.exact.toInteger¦apoc.number.exact.toInteger(stringA :: STRING?, precision = 0 :: INTEGER?, roundingMode = HALF_UP :: STRING?) :: (INTEGER?)¦apoc.number.exact.toInteger(string,[prec],[roundingMode]) - return the Integer value of a large number¦true¦
¦function¦apoc.number.format¦apoc.number.format(number :: ANY?, pattern =  :: STRING?, lang =  :: STRING?) :: (STRING?)¦apoc.number.format(number)  | format a long or double using the default system pattern and language to produce a string¦true¦
¦function¦apoc.number.parseFloat¦apoc.number.parseFloat(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (FLOAT?)¦apoc.number.parseFloat(text)  | parse a text using the default system pattern and language to produce a double¦true¦
¦function¦apoc.number.parseInt¦apoc.number.parseInt(text :: STRING?, pattern =  :: STRING?, lang =  :: STRING?) :: (INTEGER?)¦apoc.number.parseInt(text)  | parse a text using the default system pattern and language to produce a long¦true¦
¦function¦apoc.number.romanToArabic¦apoc.number.romanToArabic(romanNumber :: STRING?) :: (NUMBER?)¦apoc.number.romanToArabic(romanNumber)  | convert roman numbers to arabic¦true¦xref::mathematical/math-functions.adoc
¦function¦apoc.path.combine¦apoc.path.combine(first :: PATH?, second :: PATH?) :: (PATH?)¦apoc.path.combine(path1, path2) - combines the paths into one if the connecting node matches¦true¦xref::graph-querying/path-querying.adoc
¦function¦apoc.path.create¦apoc.path.create(startNode :: NODE?, rels = [] :: LIST? OF RELATIONSHIP?) :: (PATH?)¦apoc.path.create(startNode,[rels]) - creates a path instance of the given elements¦true¦xref::graph-querying/path-querying.adoc
¦function¦apoc.path.elements¦apoc.path.elements(path :: PATH?) :: (LIST? OF ANY?)¦apoc.path.elements(path) - returns a list of node-relationship-node-...¦true¦xref::graph-querying/path-querying.adoc
¦function¦apoc.path.slice¦apoc.path.slice(path :: PATH?, offset = 0 :: INTEGER?, length = -1 :: INTEGER?) :: (PATH?)¦apoc.path.slice(path, [offset], [length]) - creates a sub-path with the given offset and length¦true¦xref::graph-querying/path-querying.adoc
¦function¦apoc.rel.endNode¦apoc.rel.endNode(rel :: RELATIONSHIP?) :: (NODE?)¦returns endNode for (virtual) relationships¦true¦
¦function¦apoc.rel.id¦apoc.rel.id(rel :: RELATIONSHIP?) :: (INTEGER?)¦returns id for (virtual) relationships¦true¦
¦function¦apoc.rel.startNode¦apoc.rel.startNode(rel :: RELATIONSHIP?) :: (NODE?)¦returns startNode for (virtual) relationships¦true¦
¦function¦apoc.rel.type¦apoc.rel.type(rel :: RELATIONSHIP?) :: (STRING?)¦returns type for (virtual) relationships¦true¦
¦function¦apoc.schema.node.constraintExists¦apoc.schema.node.constraintExists(labelName :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)¦RETURN apoc.schema.node.constraintExists(labelName, propertyNames)¦true¦xref::indexes/schema-index-operations.adoc
¦function¦apoc.schema.node.indexExists¦apoc.schema.node.indexExists(labelName :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)¦RETURN apoc.schema.node.indexExists(labelName, propertyNames)¦true¦xref::indexes/schema-index-operations.adoc
¦function¦apoc.schema.relationship.constraintExists¦apoc.schema.relationship.constraintExists(type :: STRING?, propertyName :: LIST? OF STRING?) :: (BOOLEAN?)¦RETURN apoc.schema.relationship.constraintExists(type, propertyNames)¦true¦xref::indexes/schema-index-operations.adoc
¦function¦apoc.scoring.existence¦apoc.scoring.existence(score :: INTEGER?, exists :: BOOLEAN?) :: (FLOAT?)¦apoc.scoring.existence(5, true) returns the provided score if true, 0 if false¦true¦
¦function¦apoc.scoring.pareto¦apoc.scoring.pareto(minimumThreshold :: INTEGER?, eightyPercentValue :: INTEGER?, maximumValue :: INTEGER?, score :: INTEGER?) :: (FLOAT?)¦apoc.scoring.pareto(10, 20, 100, 11) applies a Pareto scoring function over the inputs¦true¦
¦function¦apoc.static.get¦apoc.static.get(key :: STRING?) :: (ANY?)¦apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage¦false¦xref::misc/static-values.adoc
¦function¦apoc.static.getAll¦apoc.static.getAll(prefix :: STRING?) :: (MAP?)¦apoc.static.getAll(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage¦false¦xref::misc/static-values.adoc
¦function¦apoc.temporal.format¦apoc.temporal.format(temporal :: ANY?, format = yyyy-MM-dd :: STRING?) :: (STRING?)¦apoc.temporal.format(input, format) | Format a temporal value¦true¦xref::temporal/temporal-conversions.adoc
¦function¦apoc.temporal.formatDuration¦apoc.temporal.formatDuration(input :: ANY?, format :: STRING?) :: (STRING?)¦apoc.temporal.formatDuration(input, format) | Format a Duration¦true¦xref::temporal/temporal-conversions.adoc
¦function¦apoc.temporal.toZonedTemporal¦apoc.temporal.toZonedTemporal(time :: STRING?, format = yyyy-MM-dd HH:mm:ss :: STRING?, timezone = UTC :: STRING?) :: (DATETIME?)¦apoc.temporal.toZonedTemporal('2012-12-23 23:59:59','yyyy-MM-dd HH:mm:ss', 'UTC-hour-offset') parse date string using the specified format to specified timezone¦true¦xref::temporal/temporal-conversions.adoc
¦function¦apoc.text.base64Decode¦apoc.text.base64Decode(text :: STRING?) :: (STRING?)¦apoc.text.base64Decode(text) YIELD value - Decode Base64 encoded string¦true¦
¦function¦apoc.text.base64Encode¦apoc.text.base64Encode(text :: STRING?) :: (STRING?)¦apoc.text.base64Encode(text) YIELD value - Encode a string with Base64¦true¦
¦function¦apoc.text.base64UrlDecode¦apoc.text.base64UrlDecode(url :: STRING?) :: (STRING?)¦apoc.text.base64UrlDecode(url) YIELD value - Decode Base64 encoded url¦true¦
¦function¦apoc.text.base64UrlEncode¦apoc.text.base64UrlEncode(url :: STRING?) :: (STRING?)¦apoc.text.base64UrlEncode(text) YIELD value - Encode a url with Base64¦true¦
¦function¦apoc.text.byteCount¦apoc.text.byteCount(text :: STRING?, charset = UTF-8 :: STRING?) :: (INTEGER?)¦apoc.text.byteCount(text,[charset]) - return size of text in bytes¦true¦
¦function¦apoc.text.bytes¦apoc.text.bytes(text :: STRING?, charset = UTF-8 :: STRING?) :: (LIST? OF ANY?)¦apoc.text.bytes(text,[charset]) - return bytes of the text¦true¦
¦function¦apoc.text.camelCase¦apoc.text.camelCase(text :: STRING?) :: (STRING?)¦apoc.text.camelCase(text) YIELD value - Convert a string to camelCase¦true¦
¦function¦apoc.text.capitalize¦apoc.text.capitalize(text :: STRING?) :: (STRING?)¦apoc.text.capitalize(text) YIELD value - capitalise the first letter of the word¦true¦
¦function¦apoc.text.capitalizeAll¦apoc.text.capitalizeAll(text :: STRING?) :: (STRING?)¦apoc.text.capitalizeAll(text) YIELD value - capitalise the first letter of every word in the text¦true¦
¦function¦apoc.text.charAt¦apoc.text.charAt(text :: STRING?, index :: INTEGER?) :: (INTEGER?)¦apoc.text.charAt(text, index) - the decimal value of the character at the given index¦true¦
¦function¦apoc.text.clean¦apoc.text.clean(text :: STRING?) :: (STRING?)¦apoc.text.clean(text) - strip the given string of everything except alpha numeric characters and convert it to lower case.¦true¦
¦function¦apoc.text.code¦apoc.text.code(codepoint :: INTEGER?) :: (STRING?)¦apoc.text.code(codepoint) - Returns the unicode character of the given codepoint¦true¦
¦function¦apoc.text.compareCleaned¦apoc.text.compareCleaned(text1 :: STRING?, text2 :: STRING?) :: (BOOLEAN?)¦apoc.text.compareCleaned(text1, text2) - compare the given strings stripped of everything except alpha numeric characters converted to lower case.¦true¦
¦function¦apoc.text.decapitalize¦apoc.text.decapitalize(text :: STRING?) :: (STRING?)¦apoc.text.decapitalize(text) YIELD value - decapitalize the first letter of the word¦true¦
¦function¦apoc.text.decapitalizeAll¦apoc.text.decapitalizeAll(text :: STRING?) :: (STRING?)¦apoc.text.decapitalizeAll(text) YIELD value - decapitalize the first letter of all words¦true¦
¦function¦apoc.text.distance¦apoc.text.distance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)¦apoc.text.distance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.¦true¦
¦function¦apoc.text.doubleMetaphone¦apoc.text.doubleMetaphone(value :: STRING?) :: (STRING?)¦apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value¦true¦
¦function¦apoc.text.format¦apoc.text.format(text :: STRING?, params :: LIST? OF ANY?, language = en :: STRING?) :: (STRING?)¦apoc.text.format(text,[params],language) - sprintf format the string with the params given¦true¦
¦function¦apoc.text.fuzzyMatch¦apoc.text.fuzzyMatch(text1 :: STRING?, text2 :: STRING?) :: (BOOLEAN?)¦apoc.text.fuzzyMatch(text1, text2) - check if 2 words can be matched in a fuzzy way. Depending on the length of the String it will allow more characters that needs to be edited to match the second String.¦true¦
¦function¦apoc.text.hammingDistance¦apoc.text.hammingDistance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)¦apoc.text.hammingDistance(text1, text2) - compare the given strings with the Hamming distance algorithm.¦true¦
¦function¦apoc.text.hexCharAt¦apoc.text.hexCharAt(text :: STRING?, index :: INTEGER?) :: (STRING?)¦apoc.text.hexCharAt(text, index) - the hex value string of the character at the given index¦true¦
¦function¦apoc.text.hexValue¦apoc.text.hexValue(value :: INTEGER?) :: (STRING?)¦apoc.text.hexValue(value) - the hex value string of the given number¦true¦
¦function¦apoc.text.indexOf¦apoc.text.indexOf(text :: STRING?, lookup :: STRING?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (INTEGER?)¦apoc.text.indexOf(text, lookup, from=0, to=-1==len) - find the first occurence of the lookup string in the text, from inclusive, to exclusive, -1 if not found, null if text is null.¦true¦
¦function¦apoc.text.indexesOf¦apoc.text.indexesOf(text :: STRING?, lookup :: STRING?, from = 0 :: INTEGER?, to = -1 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.text.indexesOf(text, lookup, from=0, to=-1==len) - finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.¦true¦
¦function¦apoc.text.jaroWinklerDistance¦apoc.text.jaroWinklerDistance(text1 :: STRING?, text2 :: STRING?) :: (FLOAT?)¦apoc.text.jaroWinklerDistance(text1, text2) - compare the given strings with the Jaro-Winkler distance algorithm.¦true¦
¦function¦apoc.text.join¦apoc.text.join(texts :: LIST? OF STRING?, delimiter :: STRING?) :: (STRING?)¦apoc.text.join(['text1','text2',...], delimiter) - join the given strings with the given delimiter.¦true¦
¦function¦apoc.text.levenshteinDistance¦apoc.text.levenshteinDistance(text1 :: STRING?, text2 :: STRING?) :: (INTEGER?)¦apoc.text.levenshteinDistance(text1, text2) - compare the given strings with the Levenshtein distance algorithm.¦true¦
¦function¦apoc.text.levenshteinSimilarity¦apoc.text.levenshteinSimilarity(text1 :: STRING?, text2 :: STRING?) :: (FLOAT?)¦apoc.text.levenshteinSimilarity(text1, text2) - calculate the similarity (a value within 0 and 1) between two texts.¦true¦
¦function¦apoc.text.lpad¦apoc.text.lpad(text :: STRING?, count :: INTEGER?, delim =   :: STRING?) :: (STRING?)¦apoc.text.lpad(text,count,delim) YIELD value - left pad the string to the given width¦true¦
¦function¦apoc.text.phonetic¦apoc.text.phonetic(value :: STRING?) :: (STRING?)¦apoc.text.phonetic(text) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text¦true¦
¦function¦apoc.text.random¦apoc.text.random(length :: INTEGER?, valid = A-Za-z0-9 :: STRING?) :: (STRING?)¦apoc.text.random(length, valid) YIELD value - generate a random string¦true¦
¦function¦apoc.text.regexGroups¦apoc.text.regexGroups(text :: STRING?, regex :: STRING?) :: (LIST? OF ANY?)¦apoc.text.regexGroups(text, regex) - return all matching groups of the regex on the given text.¦true¦
¦function¦apoc.text.regreplace¦apoc.text.regreplace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)¦apoc.text.regreplace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.¦true¦
¦function¦apoc.text.repeat¦apoc.text.repeat(item :: STRING?, count :: INTEGER?) :: (STRING?)¦apoc.text.repeat(item, count) - string multiplication¦true¦
¦function¦apoc.text.replace¦apoc.text.replace(text :: STRING?, regex :: STRING?, replacement :: STRING?) :: (STRING?)¦apoc.text.replace(text, regex, replacement) - replace each substring of the given string that matches the given regular expression with the given replacement.¦true¦
¦function¦apoc.text.rpad¦apoc.text.rpad(text :: STRING?, count :: INTEGER?, delim =   :: STRING?) :: (STRING?)¦apoc.text.rpad(text,count,delim) YIELD value - right pad the string to the given width¦true¦
¦function¦apoc.text.slug¦apoc.text.slug(text :: STRING?, delim = - :: STRING?) :: (STRING?)¦apoc.text.slug(text, delim) - slug the text with the given delimiter¦true¦
¦function¦apoc.text.snakeCase¦apoc.text.snakeCase(text :: STRING?) :: (STRING?)¦apoc.text.snakeCase(text) YIELD value - Convert a string to snake-case¦true¦
¦function¦apoc.text.sorensenDiceSimilarity¦apoc.text.sorensenDiceSimilarity(text1 :: STRING?, text2 :: STRING?, languageTag = en :: STRING?) :: (FLOAT?)¦apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) - compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag¦true¦
¦function¦apoc.text.split¦apoc.text.split(text :: STRING?, regex :: STRING?, limit = 0 :: INTEGER?) :: (LIST? OF ANY?)¦apoc.text.split(text, regex, limit) - splits the given text around matches of the given regex.¦true¦
¦function¦apoc.text.swapCase¦apoc.text.swapCase(text :: STRING?) :: (STRING?)¦apoc.text.swapCase(text) YIELD value - Swap the case of a string¦true¦
¦function¦apoc.text.toCypher¦apoc.text.toCypher(value :: ANY?, config = {} :: MAP?) :: (STRING?)¦apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end}) | tries it's best to convert the value to a cypher-property-string¦true¦
¦function¦apoc.text.toUpperCase¦apoc.text.toUpperCase(text :: STRING?) :: (STRING?)¦apoc.text.toUpperCase(text) YIELD value - Convert a string to UPPER_CASE¦true¦
¦function¦apoc.text.upperCamelCase¦apoc.text.upperCamelCase(text :: STRING?) :: (STRING?)¦apoc.text.upperCamelCase(text) YIELD value - Convert a string to camelCase¦true¦
¦function¦apoc.text.urldecode¦apoc.text.urldecode(text :: STRING?) :: (STRING?)¦apoc.text.urldecode(text) - return the urldecoded text¦true¦
¦function¦apoc.text.urlencode¦apoc.text.urlencode(text :: STRING?) :: (STRING?)¦apoc.text.urlencode(text) - return the urlencoded text¦true¦
¦function¦apoc.trigger.nodesByLabel¦apoc.trigger.nodesByLabel(labelEntries :: ANY?, label :: STRING?) :: (LIST? OF ANY?)¦¦false¦xref::background-operations/triggers.adoc
¦function¦apoc.trigger.propertiesByKey¦apoc.trigger.propertiesByKey(propertyEntries :: MAP?, key :: STRING?) :: (LIST? OF ANY?)¦¦false¦xref::background-operations/triggers.adoc
¦function¦apoc.ttl.config¦apoc.ttl.config() :: (MAP?)¦¦false¦xref::graph-updates/ttl.adoc
¦function¦apoc.util.compress¦apoc.util.compress(data :: STRING?, config = {} :: MAP?) :: (BYTEARRAY?)¦apoc.util.compress(string, \{config}) | return a compressed byte[] in various format from a string¦true¦
¦function¦apoc.util.decompress¦apoc.util.decompress(data :: BYTEARRAY?, config = {} :: MAP?) :: (STRING?)¦apoc.util.decompress(compressed, \{config}) | return a string from a compressed byte[] in various format¦true¦
¦function¦apoc.util.md5¦apoc.util.md5(values :: LIST? OF ANY?) :: (STRING?)¦apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list¦true¦xref::misc/text-functions.adoc#text-functions-hashing
¦function¦apoc.util.sha1¦apoc.util.sha1(values :: LIST? OF ANY?) :: (STRING?)¦apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list¦true¦xref::misc/text-functions.adoc#text-functions-hashing
¦function¦apoc.util.sha256¦apoc.util.sha256(values :: LIST? OF ANY?) :: (STRING?)¦apoc.util.sha256([values]) | computes the sha256 of the concatenation of all string values of the list¦true¦
¦function¦apoc.util.sha384¦apoc.util.sha384(values :: LIST? OF ANY?) :: (STRING?)¦apoc.util.sha384([values]) | computes the sha384 of the concatenation of all string values of the list¦true¦
¦function¦apoc.util.sha512¦apoc.util.sha512(values :: LIST? OF ANY?) :: (STRING?)¦apoc.util.sha512([values]) | computes the sha512 of the concatenation of all string values of the list¦true¦
¦function¦apoc.util.validatePredicate¦apoc.util.validatePredicate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: (BOOLEAN?)¦apoc.util.validatePredicate(predicate, message, params) | if the predicate yields to true raise an exception else returns true, for use inside WHERE subclauses¦true¦
¦function¦apoc.version¦apoc.version() :: (STRING?)¦RETURN apoc.version() | return the current APOC installed version¦true¦
¦function¦apoc.xml.parse¦apoc.xml.parse(data :: STRING?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (MAP?)¦RETURN apoc.xml.parse(<xml string>, <xPath string>, config, false) AS value¦true¦xref::import/xml.adoc
