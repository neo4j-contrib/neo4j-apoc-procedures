¦signature
¦apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)
¦apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (value :: LIST? OF ANY?)
¦apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)
¦apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)
¦apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)
¦apoc.coll.avg(numbers :: LIST? OF NUMBER?) :: (FLOAT?)
¦apoc.coll.combinations(coll :: LIST? OF ANY?, minSelect :: INTEGER?, maxSelect = -1 :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.contains(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)
¦apoc.coll.containsAll(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)
¦apoc.coll.containsAllSorted(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)
¦apoc.coll.containsDuplicates(coll :: LIST? OF ANY?) :: (BOOLEAN?)
¦apoc.coll.containsSorted(coll :: LIST? OF ANY?, value :: ANY?) :: (BOOLEAN?)
¦apoc.coll.different(values :: LIST? OF ANY?) :: (BOOLEAN?)
¦apoc.coll.disjunction(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.dropDuplicateNeighbors(list :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.duplicates(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.duplicatesWithCount(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.fill(item :: STRING?, count :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.flatten(coll :: LIST? OF ANY?, recursive = false :: BOOLEAN?) :: (LIST? OF ANY?)
¦apoc.coll.frequencies(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.frequenciesAsMap(coll :: LIST? OF ANY?) :: (MAP?)
¦apoc.coll.indexOf(coll :: LIST? OF ANY?, value :: ANY?) :: (INTEGER?)
¦apoc.coll.insert(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)
¦apoc.coll.insertAll(coll :: LIST? OF ANY?, index :: INTEGER?, values :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.intersection(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.isEqualCollection(coll :: LIST? OF ANY?, values :: LIST? OF ANY?) :: (BOOLEAN?)
¦apoc.coll.max(values :: LIST? OF ANY?) :: (ANY?)
¦apoc.coll.min(values :: LIST? OF ANY?) :: (ANY?)
¦apoc.coll.occurrences(coll :: LIST? OF ANY?, item :: ANY?) :: (INTEGER?)
¦apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.pairs(list :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.pairsMin(list :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.randomItem(coll :: LIST? OF ANY?) :: (ANY?)
¦apoc.coll.randomItems(coll :: LIST? OF ANY?, itemCount :: INTEGER?, allowRepick = false :: BOOLEAN?) :: (LIST? OF ANY?)
¦apoc.coll.remove(coll :: LIST? OF ANY?, index :: INTEGER?, length = 1 :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.removeAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.reverse(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.runningTotal(list :: LIST? OF NUMBER?) :: (LIST? OF ANY?)
¦apoc.coll.set(coll :: LIST? OF ANY?, index :: INTEGER?, value :: ANY?) :: (LIST? OF ANY?)
¦apoc.coll.shuffle(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.sort(coll :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.sortMaps(coll :: LIST? OF MAP?, prop :: STRING?) :: (LIST? OF ANY?)
¦apoc.coll.sortMulti(coll :: LIST? OF MAP?, orderFields = [] :: LIST? OF STRING?, limit = -1 :: INTEGER?, skip = 0 :: INTEGER?) :: (LIST? OF ANY?)
¦apoc.coll.sortNodes(coll :: LIST? OF NODE?, prop :: STRING?) :: (LIST? OF ANY?)
¦apoc.coll.sortText(coll :: LIST? OF STRING?, conf = {} :: MAP?) :: (LIST? OF ANY?)
¦apoc.coll.stdev(list :: LIST? OF NUMBER?, isBiasCorrected = true :: BOOLEAN?) :: (NUMBER?)
¦apoc.coll.subtract(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.sum(numbers :: LIST? OF NUMBER?) :: (FLOAT?)
¦apoc.coll.sumLongs(numbers :: LIST? OF NUMBER?) :: (INTEGER?)
¦apoc.coll.toSet(values :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.union(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.unionAll(first :: LIST? OF ANY?, second :: LIST? OF ANY?) :: (LIST? OF ANY?)
¦apoc.coll.zip(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (LIST? OF ANY?)
