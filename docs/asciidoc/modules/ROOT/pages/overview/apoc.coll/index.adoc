////
This file is generated by DocsTest, so don't change it!
////

= apoc.coll
:description: This section contains reference documentation for the apoc.coll procedures.

[.procedures, opts=header, cols='5a,1a,1a']
|===
| Qualified Name | Type | Release
|xref::overview/apoc.coll/apoc.coll.elements.adoc[apoc.coll.elements icon:book[]]

apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.pairWithOffset.adoc[apoc.coll.pairWithOffset icon:book[]]

apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.partition.adoc[apoc.coll.partition icon:book[]]

apoc.coll.partition(list,batchSize)
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.split.adoc[apoc.coll.split icon:book[]]

apoc.coll.split(list,value) \| splits collection on given values rows of lists, value itself will not be part of resulting lists
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.zipToRows.adoc[apoc.coll.zipToRows icon:book[]]

apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.avg.adoc[apoc.coll.avg icon:book[]]

apoc.coll.avg([0.5,1,2.3])
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.combinations.adoc[apoc.coll.combinations icon:book[]]

apoc.coll.combinations(coll, minSelect, maxSelect:minSelect) - Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.contains.adoc[apoc.coll.contains icon:book[]]

apoc.coll.contains(coll, value) optimized contains operation (using a HashSet) (returns single row or not)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.containsAll.adoc[apoc.coll.containsAll icon:book[]]

apoc.coll.containsAll(coll, values) optimized contains-all operation (using a HashSet) (returns single row or not)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.containsAllSorted.adoc[apoc.coll.containsAllSorted icon:book[]]

apoc.coll.containsAllSorted(coll, value) optimized contains-all on a sorted list operation (Collections.binarySearch) (returns single row or not)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.containsDuplicates.adoc[apoc.coll.containsDuplicates icon:book[]]

apoc.coll.containsDuplicates(coll) - returns true if a collection contains duplicate elements
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.containsSorted.adoc[apoc.coll.containsSorted icon:book[]]

apoc.coll.containsSorted(coll, value) optimized contains on a sorted list operation (Collections.binarySearch) (returns single row or not)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.different.adoc[apoc.coll.different icon:book[]]

apoc.coll.different(values) - returns true if values are different
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.disjunction.adoc[apoc.coll.disjunction icon:book[]]

apoc.coll.disjunction(first, second) - returns the disjunct set of the two lists
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.dropDuplicateNeighbors.adoc[apoc.coll.dropDuplicateNeighbors icon:book[]]

apoc.coll.dropDuplicateNeighbors(list) - remove duplicate consecutive objects in a list
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.duplicates.adoc[apoc.coll.duplicates icon:book[]]

apoc.coll.duplicates(coll) - returns a list of duplicate items in the collection
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.duplicatesWithCount.adoc[apoc.coll.duplicatesWithCount icon:book[]]

apoc.coll.duplicatesWithCount(coll) - returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.fill.adoc[apoc.coll.fill icon:book[]]

apoc.coll.fill(item, count) - returns a list with the given count of items
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.flatten.adoc[apoc.coll.flatten icon:book[]]

apoc.coll.flatten(coll, [recursive]) - flattens list (nested if recursive is true)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.frequencies.adoc[apoc.coll.frequencies icon:book[]]

apoc.coll.frequencies(coll) - returns a list of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]`)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.frequenciesAsMap.adoc[apoc.coll.frequenciesAsMap icon:book[]]

apoc.coll.frequenciesAsMap(coll) - return a map of frequencies of the items in the collection, key `item`, value `count` (e.g., `{1:2, 2:1}`)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.indexOf.adoc[apoc.coll.indexOf icon:book[]]

apoc.coll.indexOf(coll, value) \| position of value in the list
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.insert.adoc[apoc.coll.insert icon:book[]]

apoc.coll.insert(coll, index, value) \| insert value at index
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.insertAll.adoc[apoc.coll.insertAll icon:book[]]

apoc.coll.insertAll(coll, index, values) \| insert values at index
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.intersection.adoc[apoc.coll.intersection icon:book[]]

apoc.coll.intersection(first, second) - returns the unique intersection of the two lists
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.isEqualCollection.adoc[apoc.coll.isEqualCollection icon:book[]]

apoc.coll.isEqualCollection(coll, values) return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.max.adoc[apoc.coll.max icon:book[]]

apoc.coll.max([0.5,1,2.3])
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.min.adoc[apoc.coll.min icon:book[]]

apoc.coll.min([0.5,1,2.3])
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.occurrences.adoc[apoc.coll.occurrences icon:book[]]

apoc.coll.occurrences(coll, item) - returns the count of the given item in the collection
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.pairWithOffset.adoc[apoc.coll.pairWithOffset icon:book[]]

apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.pairs.adoc[apoc.coll.pairs icon:book[]]

apoc.coll.pairs([1,2,3]) returns [1,2],[2,3],[3,null] 
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.pairsMin.adoc[apoc.coll.pairsMin icon:book[]]

apoc.coll.pairsMin([1,2,3]) returns [1,2],[2,3]
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.partition.adoc[apoc.coll.partition icon:book[]]

apoc.coll.partition(list,batchSize)
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.randomItem.adoc[apoc.coll.randomItem icon:book[]]

apoc.coll.randomItem(coll)- returns a random item from the list, or null on an empty or null list
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.randomItems.adoc[apoc.coll.randomItems icon:book[]]

apoc.coll.randomItems(coll, itemCount, allowRepick: false) - returns a list of itemCount random items from the original list, optionally allowing picked elements to be picked again
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.remove.adoc[apoc.coll.remove icon:book[]]

apoc.coll.remove(coll, index, [length=1]) \| remove range of values from index to length
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.removeAll.adoc[apoc.coll.removeAll icon:book[]]

apoc.coll.removeAll(first, second) - returns first list with all elements of second list removed
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.reverse.adoc[apoc.coll.reverse icon:book[]]

apoc.coll.reverse(coll) - returns reversed list
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.runningTotal.adoc[apoc.coll.runningTotal icon:book[]]

apoc.coll.runningTotal(list1) - returns an accumulative array. For example apoc.coll.runningTotal([1,2,3.5]) return [1,3,6.5]
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.set.adoc[apoc.coll.set icon:book[]]

apoc.coll.set(coll, index, value) \| set index to value
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.shuffle.adoc[apoc.coll.shuffle icon:book[]]

apoc.coll.shuffle(coll) - returns the shuffled list
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sort.adoc[apoc.coll.sort icon:book[]]

apoc.coll.sort(coll) sort on Collections
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sortMaps.adoc[apoc.coll.sortMaps icon:book[]]

apoc.coll.sortMaps([maps], 'name') - sort maps by property
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sortMulti.adoc[apoc.coll.sortMulti icon:book[]]

apoc.coll.sortMulti(coll, ['^name','age'],[limit],[skip]) - sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sortNodes.adoc[apoc.coll.sortNodes icon:book[]]

apoc.coll.sortNodes([nodes], 'name') sort nodes by property
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sortText.adoc[apoc.coll.sortText icon:book[]]

apoc.coll.sortText(coll) sort on string based collections
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.stdev.adoc[apoc.coll.stdev icon:book[]]

apoc.coll.stdev(list, isBiasCorrected) - returns the sample or population standard deviation with isBiasCorrected true or false respectively. For example apoc.coll.stdev([10, 12, 23]) return 7
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.subtract.adoc[apoc.coll.subtract icon:book[]]

apoc.coll.subtract(first, second) - returns unique set of first list with all elements of second list removed
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sum.adoc[apoc.coll.sum icon:book[]]

apoc.coll.sum([0.5,1,2.3])
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.sumLongs.adoc[apoc.coll.sumLongs icon:book[]]

apoc.coll.sumLongs([1,3,3])
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.toSet.adoc[apoc.coll.toSet icon:book[]]

apoc.coll.toSet([list]) returns a unique list backed by a set
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.union.adoc[apoc.coll.union icon:book[]]

apoc.coll.union(first, second) - creates the distinct union of the 2 lists
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.unionAll.adoc[apoc.coll.unionAll icon:book[]]

apoc.coll.unionAll(first, second) - creates the full union with duplicates of the two lists
|label:function[]
|label:apoc-core[]
|xref::overview/apoc.coll/apoc.coll.zip.adoc[apoc.coll.zip icon:book[]]

apoc.coll.zip([list1],[list2])
|label:function[]
|label:apoc-core[]
|===

