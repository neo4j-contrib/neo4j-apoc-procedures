////
This file is generated by DocsTest, so don't change it!
////

= apoc.refactor
:description: This section contains reference documentation for the apoc.refactor procedures.

[.procedures, opts=header, cols='5a,1a,1a']
|===
| Qualified Name | Type | Release
|xref::overview/apoc.refactor/apoc.refactor.categorize.adoc[apoc.refactor.categorize icon:book[]]

apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.cloneNodes.adoc[apoc.refactor.cloneNodes icon:book[]]

apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.cloneNodesWithRelationships.adoc[apoc.refactor.cloneNodesWithRelationships icon:book[]]

apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.cloneSubgraph.adoc[apoc.refactor.cloneSubgraph icon:book[]]

apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error \| clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.cloneSubgraphFromPaths.adoc[apoc.refactor.cloneSubgraphFromPaths icon:book[]]

apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error \| from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.collapseNode.adoc[apoc.refactor.collapseNode icon:book[]]

apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.deleteAndReconnect.adoc[apoc.refactor.deleteAndReconnect icon:book[]]

apoc.refactor.deleteAndReconnect([pathLinkedList], [nodesToRemove], \{config}) - Removes some nodes from a linked list
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.extractNode.adoc[apoc.refactor.extractNode icon:book[]]

apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.from.adoc[apoc.refactor.from icon:book[]]

apoc.refactor.from(rel, startNode) redirect relationship to use new start-node
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.invert.adoc[apoc.refactor.invert icon:book[]]

apoc.refactor.invert(rel) inverts relationship direction
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.mergeNodes.adoc[apoc.refactor.mergeNodes icon:book[]]

apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.mergeRelationships.adoc[apoc.refactor.mergeRelationships icon:book[]]

apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.normalizeAsBoolean.adoc[apoc.refactor.normalizeAsBoolean icon:book[]]

apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.rename.label.adoc[apoc.refactor.rename.label icon:book[]]

apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) \| rename a label from 'oldLabel' to 'newLabel' for all nodes. If 'nodes' is provided renaming is applied to this set only
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.rename.nodeProperty.adoc[apoc.refactor.rename.nodeProperty icon:book[]]

apoc.refactor.rename.nodeProperty(oldName, newName, [nodes], \{config}) \| rename all node's property from 'oldName' to 'newName'. If 'nodes' is provided renaming is applied to this set only
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.rename.type.adoc[apoc.refactor.rename.type icon:book[]]

apoc.refactor.rename.type(oldType, newType, [rels], \{config}) \| rename all relationships with type 'oldType' to 'newType'. If 'rels' is provided renaming is applied to this set only
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.rename.typeProperty.adoc[apoc.refactor.rename.typeProperty icon:book[]]

apoc.refactor.rename.typeProperty(oldName, newName, [rels], \{config}) \| rename all relationship's property from 'oldName' to 'newName'. If 'rels' is provided renaming is applied to this set only
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.setType.adoc[apoc.refactor.setType icon:book[]]

apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type
|label:procedure[]
|label:apoc-core[]
|xref::overview/apoc.refactor/apoc.refactor.to.adoc[apoc.refactor.to icon:book[]]

  apoc.refactor.to(rel, endNode) redirect relationship to use new end-node
|label:procedure[]
|label:apoc-core[]
|===

