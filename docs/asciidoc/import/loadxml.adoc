[[load-xml]]
= Load XML

[abstract]
--
This section describes procedures that can be used to import data from XML files.
--

Many existing (enterprise) applications, endpoints and files use XML as data exchange format.

We can process these files using `apoc.load.xml`.
It takes a file or HTTP URL and parses the XML into a map data structure.

NOTE: in previous releases we've had `apoc.load.xmlSimple`. This is now deprecated and hsa been superseeded by `apoc.load.xml(url, [xPath], [config], true)`.Simple XML Format

See the following usage-examples for the procedures.

== Example File

"How do you access XML doc attributes in children fields ?"

(Thanks Nicolas Rouyer)

For example, if my XML file is the example https://msdn.microsoft.com/en-us/library/ms762271%28v=vs.85%29.aspx[book.xml provided by Microsoft].

[source,xml]
----
<?xml version="1.0"?>
<catalog>
   <book id="bk101">
      <author>Gambardella, Matthew</author>
      <title>XML Developer's Guide</title>
      <genre>Computer</genre>
      <price>44.95</price>
      <publish_date>2000-10-01</publish_date>
      <description>An in-depth look at creating applications
      with XML.</description>
   </book>
   <book id="bk102">
      <author>Ralls, Kim</author>
      <title>Midnight Rain</title>
      <genre>Fantasy</genre>
      <price>5.95</price>
      <publish_date>2000-12-16</publish_date>
      <description>A former architect battles corporate zombies,
...
----

We have the file here, https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml[on GitHub].

== Simple XML Format

In a simpler XML representation, each type of children gets it's own entry within the parent map.
The element-type as key is prefixed with "_" to prevent collisions with attributes.

If there is a single element, then the entry will just have that element as value, not a collection.
If there is more than one element there will be a list of values.

Each child will still have its `_type` field to discern them.

Here is the example file from above loaded with `apoc.load.xmlSimple`

[source,cypher,subs=attributes]
----
call apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml", '', {}, true)
----

[source,javascript]
----
{_type: "catalog", _book: [
  {_type: "book", id: "bk101",
    _author: [{_type: "author", _text: "Gambardella, Matthew"},{_type: author, _text: "Arciniegas, Fabio"}],
    _title: {_type: "title", _text: "XML Developer's Guide"},
    _genre: {_type: "genre", _text: "Computer"},
    _price: {_type: "price", _text: "44.95"},
    _publish_date: {_type: "publish_date", _text: "2000-10-01"},
    _description: {_type: description, _text: An in-depth look at creating applications ....
----

=== Simple XML Examples

.Example 1
[source,cypher]
----
WITH "https://maps.googleapis.com/maps/api/directions/xml?origin=Mertens%20en%20Torfsstraat%2046,%202018%20Antwerpen&destination=Rubensstraat%2010,%202300%20Turnhout&sensor=false&mode=bicycling&alternatives=false&key=AIzaSyAPPIXGudOyHD_KAa2f_1l_QVNbsd_pMQs" AS url
CALL apoc.load.xmlSimple(url)
YIELD value
RETURN value._route._leg._distance._value, keys(value), keys(value._route), keys(value._route._leg), keys(value._route._leg._distance._value)
----
image::apoc.load.xmlSimple.ex1.png[scaledwidth="100%"]

.Example 2
[source,cypher]
----
WITH "https://maps.googleapis.com/maps/api/directions/xml?origin=Mertens%20en%20Torfsstraat%2046,%202018%20Antwerpen&destination=Rubensstraat%2010,%202300%20Turnhout&sensor=false&mode=bicycling&alternatives=false&key=AIzaSyAPPIXGudOyHD_KAa2f_1l_QVNbsd_pMQs" AS url
CALL apoc.load.xmlSimple(url)
YIELD value
UNWIND keys(value) AS key
RETURN key, apoc.meta.type(value[key]);
----
image::apoc.load.xmlSimple.ex2.png[scaledwidth="100%"]



=== HTTP Headers

You can provide a map of HTTP headers to the config property.

[source,cypher]
----
WITH { `X-API-KEY`: 'abc123' } as headers,
WITH "https://myapi.com/api/v1/" AS url
CALL apoc.load.xml(url, '', { headers: headers })
YIELD value
UNWIND keys(value) AS key
RETURN key, apoc.meta.type(value[key]);
----

== xPath

It's possible to define a xPath (optional) to selecting nodes from the XML document.

=== xPath Example

From the Microsoft's book.xml file we can get only the books that have as `genre` Computer

[source,cypher,subs=attributes]
----
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml", '/catalog/book[genre=\"Computer\"]')
YIELD value as book
WITH book.id as id, [attr IN book._children WHERE attr._type IN ['title','price'] | attr._text] as pairs
RETURN id, pairs[0] as title, pairs[1] as price
----

image::apoc.load.xml.xpath.png[scaledwidth="100%"]

In this case we return only `id`, `title` and `prize` but we can return any other elements

We can also return just a single specific element.
For example the `author` of the book with `id = bg102`

[source,cypher,subs=attributes]
----
call apoc.load.xml('https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml', '/catalog/book[@id="bk102"]/author')
YIELD value as result
WITH result._text as author
RETURN author
----

image::apoc.load.xml.xpath2.png[scaledwidth="100%"]



== Load XML and Introspect

Let's just load it and see what it looks like.
It's returned as value map with nested `_type` and `_children` fields, per group of elements.
Attributes are turned into map-entries.
And each element into their own little map with `_type`, attributes and `_children` if applicable.

[source,cypher,subs=attributes]
----
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml")
----

[source,javascript]
----
{_type: catalog, _children: [
  {_type: book, id: bk101, _children: [
    {_type: author, _text: Gambardella, Matthew}, 
    {_type: title, _text: XML Developer's Guide}, 
    {_type: genre, _text: Computer}, 
    {_type: price, _text: 44.95}, 
    {_type: publish_date, _text: 2000-10-01}, 
    {_type: description, _text: An in-depth look at creating applications ....
----

=== For each book, how do I access book id ?

You can access attributes per element directly.

[source,cypher,subs=attributes]
----
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml")
YIELD value as catalog
UNWIND catalog._children as book
RETURN book.id
----

.Results
[opts="header",cols="1"]
|===
| book.id
| bk101
| bk102
|===


=== For each book, how do I access book author and title ?

==== Filter into collection

You have to filter over the sub-elements  in the `_childrens` array in this case.

[source,cypher,subs=attributes]
----
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml")
YIELD value as catalog
UNWIND catalog._children as book
RETURN book.id, [attr IN book._children WHERE attr._type IN ['author','title'] | [attr._type, attr._text]] as pairs
----

.Results
[opts="header",cols="1,1"]
|===
| book.id | pairs
| bk101 | \[[author, Gambardella, Matthew], [title, XML Developer's Guide]]
| book.id | \[[author, Ralls, Kim], [title, Midnight Rain]]
|===


==== How do I return collection elements?

This is not too nice, we could also just have returned the values and then grabbed them out of the list, but that relies on element-order.

[source,cypher,subs=attributes]
----
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml")
YIELD value as catalog
UNWIND catalog._children as book
WITH book.id as id, [attr IN book._children WHERE attr._type IN ['author','title'] | attr._text] as pairs
RETURN id, pairs[0] as author, pairs[1] as title
----

.Results
[opts="header",cols="1,1,1"]
|===
| id | author | title
| bk101 | Gambardella, Matthew | XML Developer's Guide
| bk102 | Ralls, Kim          | Midnight Rain
|===

== Extracting Datastructures

=== Turn Pairs into Map

So better is to turn them into a map with `apoc.map.fromPairs`

[source,cypher,subs=attributes]
----
call apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml") yield value as catalog
UNWIND catalog._children as book
WITH book.id as id, [attr IN book._children WHERE attr._type IN ['author','title'] | [attr._type, attr._text]] as pairs
CALL apoc.map.fromPairs(pairs) yield value
RETURN id, value
----

.Results
[opts="header",cols="1,1"]
|===
| id | value
| bk101 | {author: Gambardella, Matthew, title: XML Developer's Guide}
| bk102 | {author: Ralls, Kim, title: Midnight Rain}
| bk103 | {author: Corets, Eva, title: Maeve Ascendant}
|===

==== Return individual Columns

And now we can cleanly access the attributes from the map.

[source,cypher,subs=attributes]
----
call apoc.load.xml("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml") yield value as catalog
UNWIND catalog._children as book
WITH book.id as id, [attr IN book._children WHERE attr._type IN ['author','title'] | [attr._type, attr._text]] as pairs
CALL apoc.map.fromPairs(pairs) yield value
RETURN id, value.author, value.title
----

.Results
[opts="header",cols="1,1,1"]
|===
| id | value.author | value.title
| bk101 | Gambardella, Matthew | XML Developer's Guide
| bk102 | Ralls, Kim  | Midnight Rain
| bk103 | Corets, Eva | Maeve Ascendant
|===

== import xml directly

In case you don't want to transform your xml (like you do with `apoc.load.xml/apoc.load.xmlSimple` before you create nodes and relationships and you want to have a 1:1 mapping of xml into the graph you can use `apoc.xml.import`.

=== usage

[source,cypher]
----
CALL apoc.xml.import(<url>, <config-map>?) YIELD node
----

The procedure will return a node representing the xml document containing nodes/rels underneath mapping to the xml structure. The following mapping rules are applied:

[options="header"]
|===
| xml | label | properties
| document | XmlDocument | _xmlVersion, _xmlEncoding
| processing instruction | XmlProcessingInstruction | _piData, _piTarget
| Element/Tag | XmlTag | _name
| Attribute | n/a | property in the XmlTag node
| Text | XmlWord | for each word a separate node is created
|===

The nodes for the xml document are connected:

[options="header"]
|===
| relationship type | description
| :IS_CHILD_OF | pointing to a nested xml element
| :FIRST_CHILD_OF | pointing to the first child
| :NEXT_SIBLING | pointing to the next xml element on the same nesting level
| :NEXT | produces a linear chain through the full document
| :NEXT_WORD | only produced if config map has `createNextWordRelationships:true`. Connects words in xml to a text flow.
|===

The following options are available for the `config` map:

[options="header"]
|===
| config option | default value | description
| connectCharacters | false | if `true` the xml text elements are child nodes of their tags, interconnected by relationships of type `relType` (see below)
| filterLeadingWhitespace | false |  if `true` leading whitespace is skipped for each line
| delimiter | `\s` (regex whitespace) | if given, split text elements with the delimiter into separate nodes
| label | XmlCharacter | label to use for text element representation
| relType | `NE` | relationship type to be used for connecting the text elements into one linked list
| charactersForTag | {} | map of tagname -> string. For the given tag names an additional text element is added containing the value as `text` property. Useful e.g. for `<lb/>` tags in TEI-XML to be represented as `<lb> </lb>`.
|===


=== example

[source,cypher,subs=attributes]
----
CALL
apoc.xml.import("https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/{branch}/src/test/resources/xml/books.xml",{createNextWordRelationships:
true})
YIELD node
RETURN node;

CALL apoc.xml.import('https://seafile.rlp.net/f/6282a26504cc4f079ab9/?dl=1', {connectCharacters: true, charactersForTag:{lb:' '}, filterLeadingWhitespace: true}) yield node
return node;

----

=== Helper Function `apoc.xml.parse`

In case you have in your dataset nodes with property values XML string you can parse them into Maps
with the `apoc.xml.parse` function.

Following an example of how to use it:

```
WITH '<?xml version="1.0"?><table><tr><td><img src="pix/logo-tl.gif"></img></td></tr></table>' AS xmlString
RETURN apoc.xml.parse(xmlString) AS value
```