name,signature
algo.allShortestPaths.stream,"algo.allShortestPaths.stream(propertyName :: STRING?, config = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, distance :: FLOAT?)"
algo.articleRank,"algo.articleRank(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.articleRank.stream,"algo.articleRank.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.asPath,"algo.asPath(nodeIds = [] :: LIST? OF INTEGER?, weights = [] :: LIST? OF FLOAT?, config = {} :: MAP?) :: (path :: PATH?)"
algo.balancedTriads,"algo.balancedTriads(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, balancedTriadCount :: INTEGER?, unbalancedTriadCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, balancedProperty :: STRING?, unbalancedProperty :: STRING?)"
algo.balancedTriads.stream,"algo.balancedTriads.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, balanced :: INTEGER?, unbalanced :: INTEGER?)"
algo.beta.labelPropagation,"algo.beta.labelPropagation(label =  :: STRING?, relationship =  :: STRING?, config = null :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, didConverge :: BOOLEAN?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, weightProperty :: STRING?, write :: BOOLEAN?, seedProperty :: STRING?, writeProperty :: STRING?)"
algo.beta.labelPropagation.stream,"algo.beta.labelPropagation.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, community :: INTEGER?)"
algo.betweenness,"algo.betweenness(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?, minCentrality :: FLOAT?, maxCentrality :: FLOAT?, sumCentrality :: FLOAT?)"
algo.betweenness.sampled,"algo.betweenness.sampled(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?, minCentrality :: FLOAT?, maxCentrality :: FLOAT?, sumCentrality :: FLOAT?)"
algo.betweenness.sampled.stream,"algo.betweenness.sampled.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.betweenness.stream,"algo.betweenness.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.bfs.stream,"algo.bfs.stream(label :: STRING?, relationshipType :: STRING?, direction :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.closeness,"algo.closeness(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.dangalchev,"algo.closeness.dangalchev(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.dangalchev.stream,"algo.closeness.dangalchev.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.closeness.harmonic,"algo.closeness.harmonic(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodes :: INTEGER?)"
algo.closeness.harmonic.stream,"algo.closeness.harmonic.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.closeness.stream,"algo.closeness.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
algo.degree,"algo.degree(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.degree.stream,"algo.degree.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.dfs.stream,"algo.dfs.stream(label :: STRING?, relationshipType :: STRING?, direction :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.eigenvector,"algo.eigenvector(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.eigenvector.stream,"algo.eigenvector.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.graph.info,"algo.graph.info(name :: STRING?, degreeDistribution = null :: ANY?) :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?)"
algo.graph.list,"algo.graph.list() :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, removed :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, direction :: STRING?)"
algo.graph.load,"algo.graph.load(name =  :: STRING?, label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (name :: STRING?, graph :: STRING?, direction :: STRING?, undirected :: BOOLEAN?, sorted :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, loadMillis :: INTEGER?, alreadyLoaded :: BOOLEAN?, nodeWeight :: STRING?, relationshipWeight :: STRING?, nodeProperty :: STRING?, loadNodes :: STRING?, loadRelationships :: STRING?)"
algo.graph.load.memrec,"algo.graph.load.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.graph.remove,"algo.graph.remove(name :: STRING?) :: (name :: STRING?, type :: STRING?, exists :: BOOLEAN?, removed :: BOOLEAN?, nodes :: INTEGER?, relationships :: INTEGER?, direction :: STRING?)"
algo.infoMap,"algo.infoMap(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, iterations :: INTEGER?, communityCount :: INTEGER?)"
algo.infoMap.stream,"algo.infoMap.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, community :: INTEGER?)"
algo.kShortestPaths,"algo.kShortestPaths(startNode :: NODE?, endNode :: NODE?, k :: INTEGER?, propertyName :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, evalMillis :: INTEGER?, writeMillis :: INTEGER?, resultCount :: INTEGER?)"
algo.kShortestPaths.stream,"algo.kShortestPaths.stream(startNode :: NODE?, endNode :: NODE?, k :: INTEGER?, propertyName :: STRING?, config = {} :: MAP?) :: (index :: INTEGER?, sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
algo.labelPropagation,"algo.labelPropagation(label =  :: STRING?, relationship =  :: STRING?, config = null :: ANY?, deprecatedConfig = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, didConverge :: BOOLEAN?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, weightProperty :: STRING?, write :: BOOLEAN?, seedProperty :: STRING?, writeProperty :: STRING?)"
algo.labelPropagation.memRec,"algo.labelPropagation.memRec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.labelPropagation.stream,"algo.labelPropagation.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, label :: INTEGER?)"
algo.list,"algo.list(name =  :: STRING?) :: (name :: STRING?, description :: STRING?, signature :: STRING?, type :: STRING?)"
algo.louvain,"algo.louvain(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, iterations :: INTEGER?, modularities :: LIST? OF FLOAT?, modularity :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, includeIntermediateCommunities :: BOOLEAN?, intermediateCommunitiesWriteProperty :: STRING?, randomNeighbor :: BOOLEAN?)"
algo.louvain.memrec,"algo.louvain.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.louvain.stream,"algo.louvain.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, communities :: LIST? OF INTEGER?, community :: INTEGER?)"
algo.memrec,"algo.memrec(label =  :: STRING?, relationship =  :: STRING?, algo =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.mst,"algo.mst(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.pageRank,"algo.pageRank(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, write :: BOOLEAN?, writeProperty :: STRING?)"
algo.pageRank.memrec,"algo.pageRank.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.pageRank.stream,"algo.pageRank.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
algo.randomWalk.stream,"algo.randomWalk.stream(start = null :: ANY?, steps = 10 :: INTEGER?, walks = 1 :: INTEGER?, config = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
algo.scc,"algo.scc(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.forwardBackward.stream,"algo.scc.forwardBackward.stream(startNodeId = 0 :: INTEGER?, label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?)"
algo.scc.iterative,"algo.scc.iterative(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.iterative.stream,"algo.scc.iterative.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.multistep,"algo.scc.multistep(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.multistep.stream,"algo.scc.multistep.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.recursive.tarjan,"algo.scc.recursive.tarjan(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.recursive.tunedTarjan,"algo.scc.recursive.tunedTarjan(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.scc.recursive.tunedTarjan.stream,"algo.scc.recursive.tunedTarjan.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.scc.stream,"algo.scc.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, partition :: INTEGER?)"
algo.shortestPath,"algo.shortestPath(startNode :: NODE?, endNode :: NODE?, propertyName =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, evalMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, totalCost :: FLOAT?)"
algo.shortestPath.astar.stream,"algo.shortestPath.astar.stream(startNode :: NODE?, endNode :: NODE?, propertyName :: STRING?, propertyKeyLat = latitude :: STRING?, propertyKeyLon = longitude :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, cost :: FLOAT?)"
algo.shortestPath.deltaStepping,"algo.shortestPath.deltaStepping(startNode :: NODE?, propertyName :: STRING?, delta :: FLOAT?, config = {} :: MAP?) :: (loadDuration :: INTEGER?, evalDuration :: INTEGER?, writeDuration :: INTEGER?, nodeCount :: INTEGER?)"
algo.shortestPath.deltaStepping.stream,"algo.shortestPath.deltaStepping.stream(startNode :: NODE?, propertyName :: STRING?, delta :: FLOAT?, config = {} :: MAP?) :: (nodeId :: INTEGER?, distance :: FLOAT?)"
algo.shortestPath.stream,"algo.shortestPath.stream(startNode :: NODE?, endNode :: NODE?, propertyName =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, cost :: FLOAT?)"
algo.shortestPaths,"algo.shortestPaths(startNode :: NODE?, propertyName :: STRING?, config = {} :: MAP?) :: (loadDuration :: INTEGER?, evalDuration :: INTEGER?, writeDuration :: INTEGER?, nodeCount :: INTEGER?, targetProperty :: STRING?)"
algo.shortestPaths.stream,"algo.shortestPaths.stream(startNode :: NODE?, propertyName :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, distance :: FLOAT?)"
algo.similarity.cosine,"algo.similarity.cosine(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.cosine.stream,"algo.similarity.cosine.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.euclidean,"algo.similarity.euclidean(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.euclidean.stream,"algo.similarity.euclidean.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.jaccard,"algo.similarity.jaccard(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.jaccard.stream,"algo.similarity.jaccard.stream(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.overlap,"algo.similarity.overlap(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.overlap.stream,"algo.similarity.overlap.stream(data = null :: LIST? OF MAP?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.similarity.pearson,"algo.similarity.pearson(data = null :: ANY?, config = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, write :: BOOLEAN?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
algo.similarity.pearson.stream,"algo.similarity.pearson.stream(data = null :: ANY?, config = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
algo.spanningTree,"algo.spanningTree(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.kmax,"algo.spanningTree.kmax(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, k :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.kmin,"algo.spanningTree.kmin(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, k :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.maximum,"algo.spanningTree.maximum(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.spanningTree.minimum,"algo.spanningTree.minimum(label :: STRING?, relationshipType :: STRING?, weightProperty :: STRING?, startNodeId :: INTEGER?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
algo.triangle.stream,"algo.triangle.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeA :: INTEGER?, nodeB :: INTEGER?, nodeC :: INTEGER?)"
algo.triangleCount,"algo.triangleCount(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, triangleCount :: INTEGER?, averageClusteringCoefficient :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, clusteringCoefficientProperty :: STRING?)"
algo.triangleCount.forkJoin,"algo.triangleCount.forkJoin(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodeCount :: INTEGER?, triangleCount :: INTEGER?, averageClusteringCoefficient :: FLOAT?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, writeProperty :: STRING?, clusteringCoefficientProperty :: STRING?)"
algo.triangleCount.forkJoin.stream,"algo.triangleCount.forkJoin.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, triangles :: INTEGER?, coefficient :: FLOAT?)"
algo.triangleCount.stream,"algo.triangleCount.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, triangles :: INTEGER?, coefficient :: FLOAT?)"
algo.unionFind,"algo.unionFind(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoin,"algo.unionFind.forkJoin(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoin.stream,"algo.unionFind.forkJoin.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.forkJoinMerge,"algo.unionFind.forkJoinMerge(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.forkJoinMerge.stream,"algo.unionFind.forkJoinMerge.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.memrec,"algo.unionFind.memrec(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodes :: INTEGER?, relationships :: INTEGER?)"
algo.unionFind.mscoloring,"algo.unionFind.mscoloring(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.mscoloring.stream,"algo.unionFind.mscoloring.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, color :: INTEGER?)"
algo.unionFind.queue,"algo.unionFind.queue(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (loadMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, write :: BOOLEAN?, partitionProperty :: STRING?, writeProperty :: STRING?)"
algo.unionFind.queue.stream,"algo.unionFind.queue.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
algo.unionFind.stream,"algo.unionFind.stream(label =  :: STRING?, relationship =  :: STRING?, config = {} :: MAP?) :: (nodeId :: INTEGER?, setId :: INTEGER?)"
apoc.atomic.add,"apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.concat,"apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.insert,"apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.remove,"apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.subtract,"apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.atomic.update,"apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)"
apoc.bolt.execute,"apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.bolt.load,"apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.coll.elements,"apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)"
apoc.coll.partition,"apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)"
apoc.coll.split,"apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)"
apoc.coll.zipToRows,"apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)"
apoc.config.list,"apoc.config.list() :: (key :: STRING?, value :: ANY?)"
apoc.config.map,apoc.config.map() :: (value :: MAP?)
apoc.couchbase.append,"apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.exists,"apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (value :: BOOLEAN?)"
apoc.couchbase.get,"apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.insert,"apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.namedParamsQuery,"apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.posParamsQuery,"apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.prepend,"apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.query,"apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?) :: (queryResult :: LIST? OF MAP?)"
apoc.couchbase.remove,"apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.replace,"apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.couchbase.upsert,"apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?) :: (id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?, content :: MAP?)"
apoc.custom.list,"apoc.custom.list() :: (type :: STRING?, name :: STRING?, description :: STRING?, mode :: STRING?, statement :: STRING?, inputs :: LIST? OF LIST? OF STRING?, outputs :: ANY?, forceSingle :: BOOLEAN?)"
apoc.cypher.mapParallel,"apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)"
apoc.cypher.mapParallel2,"apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout = 10 :: INTEGER?) :: (value :: MAP?)"
apoc.cypher.parallel,"apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)"
apoc.cypher.parallel2,"apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)"
apoc.cypher.runFile,"apoc.cypher.runFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runFiles,"apoc.cypher.runFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runSchemaFile,"apoc.cypher.runSchemaFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.cypher.runSchemaFiles,"apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)"
apoc.es.get,"apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.getRaw,"apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.post,"apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)"
apoc.es.postRaw,"apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.put,"apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)"
apoc.es.query,"apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)"
apoc.es.stats,apoc.es.stats(host :: STRING?) :: (value :: MAP?)
apoc.generate.ba,"apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.complete,"apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.er,"apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.simple,"apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID"
apoc.generate.ws,"apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID"
apoc.gephi.add,"apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty = null :: STRING?, exportproperties = [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.get.nodes,apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)
apoc.get.rels,apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)
apoc.graph.from,"apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromCypher,"apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromDB,"apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromData,"apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromDocument,"apoc.graph.fromDocument(json :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromPath,"apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.fromPaths,"apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)"
apoc.graph.validateDocument,"apoc.graph.validateDocument(json :: ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.help,"apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?)"
apoc.import.csv,"apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.import.graphml,"apoc.import.graphml(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: STRING?)"
apoc.index.addAllNodes,"apoc.index.addAllNodes(index :: STRING?, structure :: MAP?, options = {} :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)"
apoc.index.addAllNodesExtended,"apoc.index.addAllNodesExtended(index :: STRING?, structure :: MAP?, options :: MAP?) :: (label :: STRING?, property :: STRING?, nodeCount :: INTEGER?)"
apoc.index.addNode,"apoc.index.addNode(node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeByLabel,"apoc.index.addNodeByLabel(label :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeByName,"apoc.index.addNodeByName(name :: STRING?, node :: NODE?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addNodeMap,"apoc.index.addNodeMap(node :: NODE?, properties :: MAP?) :: VOID"
apoc.index.addNodeMapByName,"apoc.index.addNodeMapByName(index :: STRING?, node :: NODE?, properties :: MAP?) :: VOID"
apoc.index.addRelationship,"apoc.index.addRelationship(relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addRelationshipByName,"apoc.index.addRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?, properties :: LIST? OF STRING?) :: VOID"
apoc.index.addRelationshipMap,"apoc.index.addRelationshipMap(relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID"
apoc.index.addRelationshipMapByName,"apoc.index.addRelationshipMapByName(index :: STRING?, relationship :: RELATIONSHIP?, docuemnt :: MAP?) :: VOID"
apoc.index.between,"apoc.index.between(from :: NODE?, type :: STRING?, to :: NODE?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)"
apoc.index.forNodes,"apoc.index.forNodes(name :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.forRelationships,"apoc.index.forRelationships(name :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.in,"apoc.index.in(to :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.list,"apoc.index.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.nodes,"apoc.index.nodes(label :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.orderedByText,"apoc.index.orderedByText(label :: STRING?, key :: STRING?, operator :: STRING?, value :: STRING?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.orderedRange,"apoc.index.orderedRange(label :: STRING?, key :: STRING?, min :: ANY?, max :: ANY?, relevance :: BOOLEAN?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.out,"apoc.index.out(from :: NODE?, type :: STRING?, query :: STRING?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.index.related,"apoc.index.related(nodes :: LIST? OF NODE?, label :: STRING?, key :: STRING?, relationship :: STRING?, limit :: INTEGER?) :: (node :: NODE?)"
apoc.index.relationships,"apoc.index.relationships(type :: STRING?, query :: STRING?) :: (rel :: RELATIONSHIP?, weight :: FLOAT?, start :: NODE?, end :: NODE?)"
apoc.index.remove,"apoc.index.remove(name :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
apoc.index.removeNodeByName,"apoc.index.removeNodeByName(name :: STRING?, node :: NODE?) :: VOID"
apoc.index.removeRelationshipByName,"apoc.index.removeRelationshipByName(name :: STRING?, relationship :: RELATIONSHIP?) :: VOID"
apoc.index.search,"apoc.index.search(index :: STRING?, query :: STRING?, numberOfResults = 100 :: INTEGER?) :: (node :: NODE?, weight :: FLOAT?)"
apoc.load.csv,"apoc.load.csv(url :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)"
apoc.load.driver,apoc.load.driver(driverClass :: STRING?) :: VOID
apoc.load.html,"apoc.load.html(url :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)"
apoc.load.jdbc,"apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.load.jdbcUpdate,"apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)"
apoc.load.ldap,"apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)"
apoc.load.xml,"apoc.load.xml(url :: STRING?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (value :: MAP?)"
apoc.log.debug,"apoc.log.debug(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.error,"apoc.log.error(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.info,"apoc.log.info(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.log.warn,"apoc.log.warn(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID"
apoc.metrics.get,"apoc.metrics.get(metricName :: STRING?, config = {} :: MAP?) :: (timestamp :: INTEGER?, metric :: STRING?, map :: MAP?)"
apoc.metrics.list,"apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)"
apoc.metrics.storage,"apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)"
apoc.model.jdbc,"apoc.model.jdbc(jdbc :: STRING?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
apoc.monitor.ids,"apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)"
apoc.monitor.kernel,"apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)"
apoc.monitor.locks,"apoc.monitor.locks(minWaitTime :: INTEGER?) :: (advertedDeadLocks :: INTEGER?, lockCount :: INTEGER?, contendedLockCount :: INTEGER?, minimumWaitTimeMs :: INTEGER?, contendedLocks :: LIST? OF MAP?, info :: STRING?)"
apoc.monitor.store,"apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)"
apoc.monitor.tx,"apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)"
apoc.static.get,apoc.static.get(key :: STRING?) :: (value :: ANY?)
apoc.static.getAll,apoc.static.getAll(prefix :: STRING?) :: (value :: MAP?)
apoc.static.list,"apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)"
apoc.static.set,"apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)"
apoc.util.sleep,apoc.util.sleep(duration :: INTEGER?) :: VOID
apoc.util.validate,"apoc.util.validate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: VOID"
apoc.uuid.install,"apoc.uuid.install(label :: STRING?, config = {} :: MAP?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.list,"apoc.uuid.list() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.remove,"apoc.uuid.remove(label :: STRING?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.uuid.removeAll,"apoc.uuid.removeAll() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)"
apoc.warmup.run,"apoc.warmup.run(loadProperties = false :: BOOLEAN?, loadDynamicProperties = false :: BOOLEAN?, loadIndexes = false :: BOOLEAN?) :: (pageSize :: INTEGER?, totalTime :: INTEGER?, transactionWasTerminated :: BOOLEAN?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, relGroupsPerPage :: INTEGER?, relGroupsTotal :: INTEGER?, relGroupPages :: INTEGER?, relGroupsTime :: INTEGER?, propertiesLoaded :: BOOLEAN?, dynamicPropertiesLoaded :: BOOLEAN?, propsPerPage :: INTEGER?, propRecordsTotal :: INTEGER?, propPages :: INTEGER?, propsTime :: INTEGER?, stringPropsPerPage :: INTEGER?, stringPropRecordsTotal :: INTEGER?, stringPropPages :: INTEGER?, stringPropsTime :: INTEGER?, arrayPropsPerPage :: INTEGER?, arrayPropRecordsTotal :: INTEGER?, arrayPropPages :: INTEGER?, arrayPropsTime :: INTEGER?, indexesLoaded :: BOOLEAN?, indexPages :: INTEGER?, indexTime :: INTEGER?)"
db.awaitIndex,"db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID"
db.awaitIndexes,db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID
db.createLabel,db.createLabel(newLabel :: STRING?) :: VOID
db.createProperty,db.createProperty(newProperty :: STRING?) :: VOID
db.createRelationshipType,db.createRelationshipType(newRelationshipType :: STRING?) :: VOID
db.index.explicit.addNode,"db.index.explicit.addNode(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)"
db.index.explicit.addRelationship,"db.index.explicit.addRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)"
db.index.explicit.auto.searchNodes,"db.index.explicit.auto.searchNodes(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)"
db.index.explicit.auto.searchRelationships,"db.index.explicit.auto.searchRelationships(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.auto.seekNodes,"db.index.explicit.auto.seekNodes(key :: STRING?, value :: ANY?) :: (node :: NODE?)"
db.index.explicit.auto.seekRelationships,"db.index.explicit.auto.seekRelationships(key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)"
db.index.explicit.drop,"db.index.explicit.drop(indexName :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.existsForNodes,db.index.explicit.existsForNodes(indexName :: STRING?) :: (success :: BOOLEAN?)
db.index.explicit.existsForRelationships,db.index.explicit.existsForRelationships(indexName :: STRING?) :: (success :: BOOLEAN?)
db.index.explicit.forNodes,"db.index.explicit.forNodes(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.forRelationships,"db.index.explicit.forRelationships(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.list,"db.index.explicit.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)"
db.index.explicit.removeNode,"db.index.explicit.removeNode(indexName :: STRING?, node :: NODE?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)"
db.index.explicit.removeRelationship,"db.index.explicit.removeRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)"
db.index.explicit.searchNodes,"db.index.explicit.searchNodes(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)"
db.index.explicit.searchRelationships,"db.index.explicit.searchRelationships(indexName :: STRING?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsBetween,"db.index.explicit.searchRelationshipsBetween(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsIn,"db.index.explicit.searchRelationshipsIn(indexName :: STRING?, in :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.searchRelationshipsOut,"db.index.explicit.searchRelationshipsOut(indexName :: STRING?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)"
db.index.explicit.seekNodes,"db.index.explicit.seekNodes(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?)"
db.index.explicit.seekRelationships,"db.index.explicit.seekRelationships(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)"
db.index.fulltext.awaitEventuallyConsistentIndexRefresh,db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID
db.index.fulltext.awaitIndex,"db.index.fulltext.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID"
db.index.fulltext.listAvailableAnalyzers,"db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?)"
db.index.fulltext.queryNodes,"db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?) :: (node :: NODE?, score :: FLOAT?)"
db.index.fulltext.queryRelationships,"db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?)"
db.labels,db.labels() :: (label :: STRING?)
db.propertyKeys,db.propertyKeys() :: (propertyKey :: STRING?)
db.relationshipTypes,db.relationshipTypes() :: (relationshipType :: STRING?)
db.resampleIndex,db.resampleIndex(index :: STRING?) :: VOID
db.resampleOutdatedIndexes,db.resampleOutdatedIndexes() :: VOID
db.schema,"db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
db.schema.nodeTypeProperties,"db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)"
db.schema.relTypeProperties,"db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)"
db.schema.visualization,"db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)"
db.stats.clear,"db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
db.stats.collect,"db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
db.stats.retrieve,"db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)"
db.stats.retrieveAllAnonymized,"db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)"
db.stats.status,"db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?)"
db.stats.stop,"db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)"
dbms.changePassword,dbms.changePassword(password :: STRING?) :: VOID
dbms.checkpoint,"dbms.checkpoint() :: (success :: BOOLEAN?, message :: STRING?)"
db.clearQueryCaches,db.clearQueryCaches() :: (value :: STRING?)
dbms.components,"dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)"
dbms.getTXMetaData,dbms.getTXMetaData() :: (metadata :: MAP?)
dbms.killConnection,"dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.killConnections,"dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)"
dbms.listActiveLocks,"dbms.listActiveLocks(queryId :: STRING?) :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?)"
dbms.listConfig,"dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)"
dbms.listConnections,"dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?)"
dbms.queryJmx,"dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)"
dbms.security.activateUser,"dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.addRoleToUser,"dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID"
dbms.security.changePassword,"dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID"
dbms.security.changeUserPassword,"dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.clearAuthCache,dbms.security.clearAuthCache() :: VOID
dbms.security.createRole,dbms.security.createRole(roleName :: STRING?) :: VOID
dbms.security.createUser,"dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID"
dbms.security.deleteRole,dbms.security.deleteRole(roleName :: STRING?) :: VOID
dbms.security.deleteUser,dbms.security.deleteUser(username :: STRING?) :: VOID
dbms.security.listRoles,"dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?)"
dbms.security.listRolesForUser,dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?)
dbms.security.listUsers,"dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
dbms.security.listUsersForRole,dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?)
dbms.security.removeRoleFromUser,"dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID"
dbms.security.showCurrentUser,"dbms.security.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
dbms.security.suspendUser,dbms.security.suspendUser(username :: STRING?) :: VOID
dbms.setConfigValue,"dbms.setConfigValue(setting :: STRING?, value :: STRING?) :: VOID"
dbms.setTXMetaData,dbms.setTXMetaData(data :: MAP?) :: VOID
dbms.showCurrentUser,"dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)"
